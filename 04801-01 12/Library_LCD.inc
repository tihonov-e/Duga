

;           ######################################################################
;          #                                                                    #
;         #        БИБЛИОТЕКА РАБОТЫ С ИНДИКАТОРНОЙ ПАНЕЛЬЮ DG12864-01         #
;        #              21 знак х 8 строк.   Кварц. резонатор 22118,4 кГц.    #
;       #              **************************************************    #
;      #                        Версия ПО 1.02                              #
;     #       Отличие от Ld24x890.a51: С целью улучшить помехоустойчивость #
;    #      работы блока индикации с микроконтроллером AT89S8253,         #
;   #      сделана команда отображения первой строки экранного ОЗУ в LCD #
;  #      левой и правой матрицы каждый раз, после обращения к          #
; #  подпрограмме очистки RESP, а не только в пп.LcdInit!!  29-04-2008 #
;######################################################################
    ;!!******************************************************************************************!!
   ;!! ** Отличие от версии Vn_ind92.asm: в библиотеку Ld24x893.a51 введен режим отображения знаков
  ;!! ** на дисплее кассира в режиме широкого шрифта - 16 символов Х 4 строки, ****************!!
 ;!! ** отображение знака: 7 х 10 пикселей (против 5 х 7 в обычном режиме). ******************!!
;********************************************************************************************!!

; СОДЕРЖАНИЕ:
;-------------- 1. Основные подпрограммы --------------------------------------------
; LcdInit       - общая инициализация LCD 1-8 строки, левой и правой матрицы
;                после подачи питания. ----------------------------------------------
;------------------------------------------------------------------------------------

; LcdClearBuf_0       - очистка дисплейного буфера 0.
;------------------------------------------------------------------------------------
; LcdClearBuf_1       - очистка дисплейного буфера 1.
;------------------------------------------------------------------------------------

; LcdDisplay_Buff_0   - вывод дисплейного буфера 0 на индикатор 21 символ х 8 строк.
;------------------------------------------------------------------------------------
; LcdDisplay_Buff_1   - вывод дисплейного буфера 1 на индикатор 21 символ х 8 строк.
;------------------------------------------------------------------------------------
; LcdDisplay_Tabl_1_8 - вывод данных в ASCII кодах 20 символов х 8 строк
;                       на индикатор, из таблицы ASCII в памяти программ.

;----------------------------------------------------------------------------------------------

;-------------- 2. Вспомогательные подпрограммы -----------------------------------------------
;----------------------------------------------------------------------------------------------
; RESP                - "очистка" ОЗУ контроллеров LCD левой и правой матрицы.
;----------------------------------------------------------------------------------------------
; LcdWriteSt          - запись байта (в ОЗУ или команды) графического LCD из <A> (21 знак х 8 строк).
;----------------------------------------------------------------------------------------------
; LcdReadSt           - чтение байта (ОЗУ или байта состояния) графического LCD (21 знак х 8 строк)
;----------------------------------------------------------------------------------------------
; LcdComWriteSt       - запись байта в регистр команд графического LCD (21 знак х 8 строк).
;----------------------------------------------------------------------------------------------
; LcdDataWriteSt      - запись знака в графический LCD (21 знак х 8 строк).
;----------------------------------------------------------------------------------------------
; LcdIsBusySt         - проверка состояния графического LCD (21 знак х 8 строк).
;----------------------------------------------------------------------------------------------
; SET_POZITION        - установка адреса столбца и строки (страницы ОЗУ) графического LCD
;----------------------------------------------------------------------------------------------
; LcdStrWriteSt_Buff0 - запись строк в индикатор из буфера 0.
;----------------------------------------------------------------------------------------------
; LcdStrWriteSt_Buff1 - запись строк в индикатор из буфера 1.
;----------------------------------------------------------------------------------------------
; LcdStrWriteSt_Tabl  - запись в индикатор таблицы данных в ASCII кодах
;----------------------------------------------------------------------------------------------
; LcdTrans             - кодировщик символьной таблицы графического индикатора 128х64 точки
;---------------------------------------------------------------------------------
; LCD_OUTH             - ВЫВОД 2-Х ШЕСТНАДЦАТИРИЧНЫХ ЦИФР ИЗ <A> НА LCD.
;---------------------------------------------------------------------------------
; ANCI_TO_OEM:		   - ПЕРЕКОДИРОВКА СИМВОЛОВ ИЗ ANCI В OEM
;---------------------------------------------------------------------------------
; DEC_20:			   - Преобразование 20-ти разрядного двоичного кода из однобайтовых переменных
;---------------------------------------------------------------------------------
; TEST_MODE:		   - тестовый режим работы жки индикатора
;*******************************************************************
;*           Необходимые установки в начале программы              *
;*******************************************************************

; BufferIND_0 = <Адрес переменной 6FH - FEH (111-254)   (110+144=254)>  **** Буфер индикации 0 -144 байта **
                              ; Начальный адресный вектор пользовательского буфера индикации страницы 0
                             ; в оперативной памяти.
                            ; Фиксированная длина буфера 144 байта (6 строк х 24 символа)
                           ; 6FH - FEH (111-254)   (110+144=254).
                          ; !!! Совпадает с данными ASCII буфера последовательного порта: ,
                         ; !!! при этом байт FFH (255) оперативной памяти отведён под контрольную сумму
                        ; !!! serialBufer (в режиме TS).
                       ; Обращение к данным буфера через косвенную адресацию, командами:
                      ; MOV A,@R0(R1); MOV @R0(R1),A.

; BufferIND_1 = <Адрес переменной 0000H - 008FH (0-143) В области XRAM **** Буфер индикации 1 -144 байта **
               ; Начальный адресный вектор пользовательского буфера индикации страницы 1
              ; в оперативной памяти XRAM: 0000H.
             ; Фиксированная длина буфера 144 байта (6 строк х 24 символа)
            ; 0000H - 008FH (0-143).
           ; Обращение к данным буфера командами:
          ; MOVX @DPTR,A; MOVX A,@DPTR
         ; при установленном бите EEE:=0 (EECON.1:=0) {EECON(S:D2H)}.


;R_S1  equ  P2.0 ; сигнал выбора регистра.
;R_W1  equ  P2.1 ; сигнал выбора операции чтения/записи.
;--------------------------------------------------------------------

;E1   equ  P1.5 ; тактовый сигнал контроллеров LCD левой и правой матрицы.
;CS1  equ  P1.6 ; вход выборки контроллера LCD левой матрицы.
;CS2  equ  P1.7 ; вход выборки контроллера LCD правой матрицы.
                                                                   ;-------------------------------------------------------------------

;======================================================================
; Шина данных DB4-DB7: линии P3.4 - P3.7 порта P3
; Используется банк регистров памяти 0
;=====================================================================




;****************** Основные подпрограммы ***********************************************



;**********************************************************************************
;=== 10.04.07 ====================================================================
; Общая инициализация LCD 1-8 строки, левой и правой матрицы, после подачи питания.
; Используемые регистры: ACC, B, R0, R6, R7
;===============================================================================
LcdInit:
;-----------------------------------------------------------------------------
        clr     E1              ; Сброс тактового сигнала контроллеров LCD левой и правой матрицы.
        clr     CS1            ; Сброс строба контроллера LCD левой матрицы.
        clr     CS2           ; Сброс строба контроллера LCD правой матрицы.
        ;------------------------------------------------------------------
;*********************************************************************************************
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                        ;      11...20 (0BH...14H) LCD правой матрицы.)
                       ;-----------------------------------------------------------

LcdInit_Left:
        mov     A,#3EH
        ;MOV A,00111110B
		lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;========================================================================
      ;= Команда "Выключить дисплей"- левой матрицы ============================

        mov     A,#0C0H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;================================================================================
      ;= Команда "Первая строка ОЗУ, отображаемая в верхней строке LCD"- левой матрицы =




  ;********************************************************************************************
        mov     POZITION,#0BH; Установить позицию "11" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...9 -LCD левой матрицы
                          ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                         ;      11...20 (0BH...14H) LCD правой матрицы.)
                        ;-----------------------------------------------------------
LcdInit_Right:
        //mov     A,#3EH
		mov     A,#00111111B
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;========================================================================
      ;= Команда "Выключить дисплей"- правой матрицы ============================

        mov     A,#0C0H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;================================================================================
      ;= Команда "Первая строка ОЗУ, отображаемая в верхней строке LCD"- правой матрицы =

        ;----------------------;
        lcall   RESP          ; "Очистка" ОЗУ контроллеров LCD левой и правой матрицы.
        ;--------------------;  с обнулением указателей позиции номера знака и
        ;-------------------;  позиции строки  для знака. POZITION:=0  POZ_STR:=0,
                           ;  и, с установкой для LCD левой и правой матрицы:
                          ;  страницы ОЗУ - 0; столбца 0(с учётом поправки для LCD
                         ;  левой матрицы.
        ;*************************************************************************************


        ;************************************************************************************
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                        ;      11...20 (0BH...14H) LCD правой матрицы.)
                       ;-----------------------------------------------------------

        mov     A,#3FH
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;========================================================================
      ;= Команда "Включить дисплей"- левой матрицы ============================


        ;**********************************************************************************
        mov     POZITION,#0BH; Установить позицию "11" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...9 -LCD левой матрицы
                          ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                         ;      11...20 (0BH...14H) LCD правой матрицы.)
                        ;-----------------------------------------------------------
        mov     A,#3FH
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;========================================================================
      ;= Команда "Включить дисплей"- правой матрицы ============================


        ;**********************************************************************
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;                   10...19 (0AH...13H) LCD правой матрицы.)
                        ;-----------------------------------------------------------

        ret
;************************************************************************









;=== 06.04.07  ========================================================
; Очистка дисплейного буфера 0
; Используемые регистры: ACC, R0
;====================================================================
LcdClearBuf_0:
        mov     R0,#BufferIND_0
        mov     A,#160
        ;---------------------
LcdClearBuf_0_Cukl:
        mov     @R0,#20H
        ;---------------
        inc     R0
        djnz    ACC,LcdClearBuf_0_Cukl
        ;--------------------
        ret


;=== 06.04.07  ========================================================
; Очистка дисплейного буфера 1
; Используемые регистры: ACC, B, R0
;====================================================================
LcdClearBuf_1:
        mov     DPTR,#BufferIND_1
        mov     B,#160
        ;------------
        mov     A,#20H
        ;---------------------
LcdClearBuf_1_Cukl:
        movx    @DPTR,A
        ;--------------
        inc     DPTR
        djnz    B,LcdClearBuf_1_Cukl
        ;--------------------
        ret




;=== 03.05.07 =======================================================
; Вывод дисплейного буфера 0 на индикатор: 160 символов=20х8 строк.
;====================================================================
LcdDisplay_Buff_0:
;---------------------------------
;;;        jb      Bit_OUT_LOGO_Buff0,LcdDisplay_Buff_0_Logo
                                   ; Анализ битового признака вывода логотипа
                                  ; (При установленном признаке - вывод буфера
                                 ;  без той части знаковой области, которая
                                ;  соответствует выведенному ранее логотипу).

        mov     POZITION,#0
        mov     POZ_STR,#0
        mov     KOL_SIMV,#160
;*** 03.05.07 ******** 1. Запись строк в индикатор из буфера 0. *********************
; Входные параметры:
;-------------------------------------------------------------------------------
; POZITION:= начальный адрес знакоместа 0...19 (00H...13H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...160 (01H...A0H).
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 19) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
        lcall   LcdStrWriteSt_Buff0
        clr     BIT_OUT_PAGE  ; Сбросить признак страницы (буфера индикации) выведеной
                             ; последней на индикатор.
        ret
        ;================================================================

; При установленном признаке вывода логотипа - вывод буфера 0
; без той части знаковой области, которая соответствует выводенному ранее логотипу.
LcdDisplay_Buff_0_Logo:
        mov     POZITION,#5
        mov     POZ_STR,#0
        mov     KOL_SIMV,#15
        mov     B,#5   ; Задать смещение буфера 0.
        lcall   LcdStrWriteSt_Buff0_Smesh
        ;--------------------------
        mov     POZITION,#5
        mov     POZ_STR,#1
        mov     KOL_SIMV,#15
        mov     B,#25  ; Задать смещение буфера 0.
        lcall   LcdStrWriteSt_Buff0_Smesh
        ;--------------------------
        mov     POZITION,#5
        mov     POZ_STR,#2
        mov     KOL_SIMV,#15
        mov     B,#45  ; Задать смещение буфера 0.
        lcall   LcdStrWriteSt_Buff0_Smesh
        ;--------------------------
        mov     POZITION,#5
        mov     POZ_STR,#3
        mov     KOL_SIMV,#15
        mov     B,#65  ; Задать смещение буфера 0.
        lcall   LcdStrWriteSt_Buff0_Smesh
        ;============================
        mov     POZITION,#0
        mov     POZ_STR,#4
        mov     KOL_SIMV,#80
        mov     B,#80  ; Задать смещение буфера 0.
        lcall   LcdStrWriteSt_Buff0_Smesh
        ;==========================
        clr     BIT_OUT_PAGE  ; Сбросить признак страницы (буфера индикации) выведеной
                             ; последней на индикатор.
        ret
        ;================================================================






;=== 03.05.07 =======================================================
; Вывод дисплейного буфера 1 на индикатор: 160 символов=20х8 строк.
;====================================================================
LcdDisplay_Buff_1:
;---------------------------------
;;;        jb      Bit_OUT_LOGO_Buff1,LcdDisplay_Buff_1_Logo
                                   ; Анализ битового признака вывода логотипа
                                  ; (При установленном признаке - вывод буфера
                                 ;  без той части знаковой области, которая
                                ;  соответствует выведенному ранее логотипу).

        mov     POZITION,#0
        mov     POZ_STR,#0
        mov     KOL_SIMV,#160
;*** 03.05.07 ******** 1. Запись строк в индикатор из буфера 1. *********************
; Входные параметры:
;-------------------------------------------------------------------------------
; POZITION:= начальный адрес знакоместа 0...19 (00H...13H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...160 (01H...A0H).
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 19) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
        lcall   LcdStrWriteSt_Buff1
        setb    BIT_OUT_PAGE  ; Установить признак страницы (буфера индикации) выведеной
                             ; последней на индикатор.
        ret
        ;================================================================

; При установленном признаке вывода логотипа - вывод буфера 1
; без той части знаковой области, которая соответствует выводенному ранее логотипу.
LcdDisplay_Buff_1_Logo:
        mov     POZITION,#5
        mov     POZ_STR,#0
        mov     KOL_SIMV,#15
        mov     B,#5   ; Задать смещение буфера 1.
        lcall   LcdStrWriteSt_Buff1_Smesh
        ;--------------------------
        mov     POZITION,#5
        mov     POZ_STR,#1
        mov     KOL_SIMV,#15
        mov     B,#25  ; Задать смещение буфера 1.
        lcall   LcdStrWriteSt_Buff1_Smesh
        ;--------------------------
        mov     POZITION,#5
        mov     POZ_STR,#2
        mov     KOL_SIMV,#15
        mov     B,#45  ; Задать смещение буфера 1.
        lcall   LcdStrWriteSt_Buff1_Smesh
        ;--------------------------
        mov     POZITION,#5
        mov     POZ_STR,#3
        mov     KOL_SIMV,#15
        mov     B,#65  ; Задать смещение буфера 1.
        lcall   LcdStrWriteSt_Buff1_Smesh
        ;============================
        mov     POZITION,#0
        mov     POZ_STR,#4
        mov     KOL_SIMV,#80
        mov     B,#80  ; Задать смещение буфера 1.
        lcall   LcdStrWriteSt_Buff1_Smesh
        ;==========================
        setb    BIT_OUT_PAGE  ; Установить признак страницы (буфера индикации) выведеной
                             ; последней на индикатор.
        ret
        ;================================================================






;=== 03.05.07 =============================================================
; Вывод таблицы данных в ASCII кодах на индикатор: 160 символов=20х8 строк.
;=========================================================================
LcdDisplay_Tabl_1_8:
;---------------------------------

        mov     POZITION,#0
        mov     POZ_STR,#0
        mov     KOL_SIMV,#160
;*** 03.05.07 ******** 3. Запись в индикатор таблицы данных в ASCII кодах из ****
;********************     памяти программ управляющего микроконтроллера. *******
; Входные параметры:
;-------------------------------------------------------------------------------
; POZITION:= начальный адрес знакоместа 0...19 (00H...13H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...160 (01H...A0H).
;     DPTR:= начальный адрес таблицы данных ASCII кодов в памяти программ.
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 19) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
        lcall   LcdStrWriteSt_Tabl

        ret
        ;================================================================






;***************** Вспомогательные подпрограммы **********************
            ;===============================================================================
           ; "Очистка" ("Обрезка") ОЗУ контроллеров LCD левой и правой матрицы:           =
          ;  для LCD левой матрицы - первых 4-рёх столбцов страниц 0...7 ОЗУ,            =
         ;  для LCD правой матрицы - последних 4-рёх столбцов страниц 0...7 ОЗУ.        =
        ;  Подпрограмма используется для быстрой очистки "обрезки" лишних засвеченных  =
       ;  пикселей при переходе из вывода графической информации к выводу знаков      =
      ;  (страниц), минуя сравнительно медленную подпрограмму RESP.                  =
     ; ============================================================================ =
    ; ==============================================================================
RESP_01:
        mov     zp_st,POZITION
        mov     zp_ml,POZ_STR
                ; Сохранение указателей позиции знака и строки в промежуточных переменных.
          ;*****************************************************************************
        mov     POZITION,#0
        ; Переменная POZITION определяет выбор: 0...9 -LCD левой матрицы
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                        ;      11...20 (0BH...14H) LCD правой матрицы.)
                       ;-----------------------------------------------------------

        mov     B,#64   ; Загрузка счётчика общего количества "обрезаемых" байт ОЗУ LCD
                       ; левой и правой матрицы: (4столбца х 8 страниц) х 2 = 64.
RESP_01_CUKL_NUL_PAGE:
        mov     POZ_STR,#0FFH
                          ; Установить позицию ("0"-1) строки для знака -
                         ; общая отслеживающая переменная обоих контроллеров LCD.
                        ;--------------------------------------------------------------
        mov     R4,#8  ; Установить счётчик полного числа страниц ОЗУ контроллера LCD.

RESP_01_CUKL_NEXT_PAGE:
        inc     POZ_STR ; Инкремент позиции строки для знака -
                       ; общей отслеживающей переменной обоих контроллеров LCD.
                      ;--------------------------------------------------------------

RESP_01_LCD_LEFT_RIGHT:
       ;--------------------------------------------------------------------------
        mov     A,#0B8H
        ;++++++++++++++

        push    B
        ;+++++++++++++++;
        mov     B,POZ_STR
        anl     B,#07H;
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;+++++++++++;
        pop     B

        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;========================================================================
      ;= Команда "Установить страницу ОЗУ LCD - левой/правой матрицы" =========


       ;-----------------------------------------------------------------------------------
      ;== Цикл заполнения 8-ми страниц ОЗУ LCD левой/правой матрицы ======================
     ;== данными "обрезки". =============================================================
        mov     R1,#4    ; Установить счётчик полного числа столбцов контроллера LCD
                         ; левой/правой матрицы.

        mov     A,POZITION
        cjne    A,#0BH,Obrezka_Left
Obrezka_Right:
        mov     A,#7CH
        ljmp    Obrezka_Cont
        ;------------------
Obrezka_Left:
        mov     A,#40H
Obrezka_Cont:
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;===========================================================================================
      ;= Команда "Установить адрес столбца для "обрезки" данных ОЗУ LCD - левой/правой матрицы" ==
     ;===========================================================================================


        ;** Запись в ОЗУ LCD левой/правой матрицы. ********************************
       ;**************************************************************************
RESP_01_Graphic_Port3:
      ;== Цикл заполнения одной страницы LCD левой/правой матрицы =========================
     ;== данными "обрезки". ==============================================================
        lcall   LcdIsBusySt      ; Проверка занятости индикатора
        jc      RESP_01_Graphic_Port3 ;
       ;=======================;
        ;---------------------;
        clr     A            ; A:=00H.
        mov     P2,A ; Вывод байта 00H из <A> на шину данных DB7-DB0.
;;        lcall   Out_DB7_DB0 ; Вывод байта 00H из <A> на шину данных DB7-DB0.
        ;------------------;
        setb    R_S1      ;
       ;=================;
        call    LcdWriteSt; Запись байта данных "обрезки" в LCD левой/правой матрицы.

RESP_01_Graphic_Cont:
        djnz    B,RESP_01_Graphic_Port5
                               ; Декремент оставшегося количества общего количества "обрезаемых" байт
                              ; в ОЗУ LCD левой/правой матрицы: RESP_01_Graphic_Port5).
;==============================================================================================
        mov     POZITION,zp_st
        mov     POZ_STR,zp_ml
       ; Восстановление из промежуточных переменных указателей позиции знака и строки.
    ;*******************************************************************************
        ret



           ;*******************************************************************************************
          ;===========================================================================================
         ; Анализ количества столбцов и страниц занесённых в ОЗУ LCD левой/правой матрицы
        ;============================================================================================
RESP_01_Graphic_Port5:
        djnz    R1,RESP_01_Graphic_Port3
               ; На цикл заполнении данными "обрезки"
              ; одной страницы ОЗУ LCD левой/правой матрицы.
             ;===================================================================================

        ; Страница ОЗУ LCD левой/правой матрицы уже заполнена данными "обрезки".
       ;=======================================================================================
        mov     A,POZITION
        cjne    A,#0BH,RESP_01_CUKL_LCD_RIGHT_000
        ; На цикл заполнения 8-ми страниц ОЗУ LCD правой матрицы ============================
       ; данными "обрезки".
        mov     POZITION,#0
                       ; В данном случае, POZITION определяет работу с LCD левой матрицы
                      ;--------------------------------------------------------------------
        djnz    R4,RESP_01_CUKL_NEXT_PAGE
                                     ; На цикл заполнения новой страницы ОЗУ LCD левой/правой
                                    ; матрицы данными "обрезки".
       ;********************************************************************************************
         ljmp   RESP_01_CUKL_NUL_PAGE
                                  ; Если число данных графического пакета превышает 1024 - на вывод
                                 ; оставшихся принятых байт в ОЗУ LCD, начиная со страницы 0.
     ;********************************************************************************************


  ;============================================================================================
 ;== На цикл заполнения страницы ОЗУ LCD правой матрицы данными "обрезки".
;== (ОЗУ LCD левой матрицы данными графического пакета уже заполнено.) ======================
RESP_01_CUKL_LCD_RIGHT_000:
        mov     POZITION,#0BH
                       ; В данном случае, POZITION определяет работу с LCD правой матрицы
                      ; (после работы с LCD левой матрицы на одной и той же странице).
                     ;-----------------------------------------------------------------
        ljmp    RESP_01_LCD_LEFT_RIGHT
    ;**************************************************************************************










            ;===============================================================================
           ; "Очистка" ОЗУ контроллеров LCD левой и правой матрицы.                       =
          ;  с обнулением указателей позиции номера знака и позиции строки               =
         ;  для знака: POZITION:=0  POZ_STR:=0.                                         =
        ;  и, с установкой для LCD левой и правой матрицы:                             =
       ;  страницы ОЗУ - 0; столбца 0 (с учётом поправки для LCD левой матрицы.)      =
      ;===============================================================================
     ; Последовательность "очистки": Страница ОЗУ 0...7 LCD левой матрицы;          =
    ;                               Страница ОЗУ 0...7 LCD правой матрицы.         =
   ;===============================================================================
RESP:
        ;++++++++ 29-04-2008 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        mov     POZITION,#0 ; Установить позицию "0"  начального номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;                   10...19 (0AH...13H) LCD правой матрицы.)
        mov     A,#0C0H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;================================================================================
      ;= Команда "Первая строка ОЗУ, отображаемая в верхней строке LCD"- левой матрицы =

        mov     POZITION,#0BH; Установить позицию "11" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...9 -LCD левой матрицы
                          ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                         ;      11...20 (0BH...14H) LCD правой матрицы.)
                        ;-----------------------------------------------------------
        mov     A,#0C0H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;================================================================================
      ;= Команда "Первая строка ОЗУ, отображаемая в верхней строке LCD"- правой матрицы =
        ;++++++++ 29-04-2008 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы.
                        ;      11...20 (0BH...14H) LCD правой матрицы.)
                       ;------------------------------------------------------------------
                        ;----------------------------------------------------------------
                       ; В данном случае, POZITION определяет работу с LCD левой матрицы
                      ;----------------------------------------------------------------
RESP_CUKL_LCD_RIGHT:
        mov     POZ_STR,#0FFH
                          ; Установить позицию ("0"-1) строки для знака -
                         ; общая отслеживающая переменная обоих контроллеров LCD.
                        ;--------------------------------------------------------------

        mov     R4,#8 ; Установить счётчик полного числа страниц ОЗУ контроллера LCD.
         ;---------------------------------------------------------------------------
        ;---------------------------------------------------------------------------

     ;== Цикл очистки 8-ми страниц LCD левой/правой матрицы. ==========================
RESP_CUKL_NEXT_PAGE:
        mov     R2,#64   ; Установить счётчик полного числа столбцов контроллера LCD.
        inc     POZ_STR ; Инкремент позиции строки для знака -
                       ; общей отслеживающей переменной обоих контроллеров LCD.
                      ;--------------------------------------------------------------

       ;--------------------------------------------------------------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;========================================================================
      ;= Команда "Установить страницу ОЗУ LCD - левой/правой матрицы" =========

        mov     A,#40H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;==============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой/правой матрицы" ========
     ;= (В данном случае - БЕЗ НЕОБХОДИМОСТИ использования поправки) ===============
    ;==============================================================================


     ;== Цикл "очистки" одной страницы ОЗУ LCD левой/правой матрицы. ==========
RESP_CUKL:
        mov     A,POZITION; Переменная POZITION определяет выбор: 0...9 -LCD левой матрицы
                         ;                                      10...19 (0AH...13H) LCD правой матрицы.
                        ;------------------------------------------------------------------------------
        cjne    A,#0BH,RESP_Anal
RESP_Anal:
        jc      RESP_Left ; Если позиция 0...9 для LCD левой матрицы

         ;************************************************************************
        ; Если позиция 10...19 (0AH...13H) для LCD правой матрицы.
RESP_Right:
        ;-------------;
RESP_Right_Cukl:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      RESP_Right_Cukl
       ;===========;
        ;---------------------;
        clr     A            ; A:=0.
        mov     P2,A ; Вывод байта 00H из <A> на шину данных DB7-DB0.
;;        lcall   Out_DB7_DB0 ; Вывод байта 00H из <A> на шину данных DB7-DB0.
        ;------------------;
        setb    R_S1      ;
       ;=================;
        call    LcdWriteSt; Запись байта данных ОЗУ графического LCD (20 знаков х 8 строк).

        ljmp    RESP_Cont
        ;*************************************************************************

         ;***********************************************************************
        ; Если позиция 0...9 для LCD левой матрицы.
RESP_Left:
        ;-------------;
RESP_Left_Cukl:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      RESP_Left_Cukl
       ;===========;
        ;---------------------;
        clr     A            ; A:=0.
        mov     P2,A ; Вывод байта 00H из <A> на шину данных DB7-DB0.
;;        lcall   Out_DB7_DB0 ; Вывод байта 00H из <A> на шину данных DB7-DB0.
        ;------------------;
        setb    R_S1      ;
       ;=================;
        call    LcdWriteSt; Запись байта данных ОЗУ графического LCD (20 знаков х 8 строк).

RESP_Cont:
        djnz    R2,RESP_CUKL ; На цикл "очистки" одной страницы ОЗУ LCD левой/правой матрицы.
        ;===================;

        djnz    R4,RESP_CUKL_NEXT_PAGE ; На цикл очистки 8-ми страниц
       ;==============================; ОЗУ LCD левой/правой матрицы.

        mov     A,POZITION
        cjne    A,#0BH,RESP_CUKL_LCD_RIGHT_000 ; На цикл очистки 8-ми страниц
       ;======================================; ОЗУ LCD правой матрицы.
      ;--------------------------------------; (ОЗУ LCD левой матрицы "ОЧИЩЕНО".)



   ;************************************************************************************

        mov     POZITION,#0 ; Установить позицию "0"  начального номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;                   10...19 (0AH...13H) LCD правой матрицы.)
                        ;-----------------------------------------------------------
        mov    POZ_STR,#0 ; Установить начальный адрес строки:=0.

        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
        lcall   SET_POZITION
    ;*****************************************************************************
        ret

 ;============================================================================================
;== На цикл очистки 8-ми страниц ОЗУ LCD правой матрицы. (ОЗУ LCD левой матрицы "ОЧИЩЕНО".)==
RESP_CUKL_LCD_RIGHT_000:
        mov     POZITION,#0BH
                       ; В данном случае, POZITION определяет работу с LCD правой матрицы
                      ;-----------------------------------------------------------------
        ljmp    RESP_CUKL_LCD_RIGHT
  ;**************************************************************************************






;**********************************************************************************
;=== 02.05.07 ====================================================================
; Запись байта (в ОЗУ или команды) графического LCD из <A> (21 знак х 8 строк).
;================================================================================
LcdWriteSt:
        push    ACC
        ;---------------
        clr     R_W1
        ;--------------
        
		mov     P2,A ; Вывод байта 00H из <A> на шину данных DB7-DB0.
;;        lcall   Out_DB7_DB0  ; Вывод байта из <A> на шину данных DB7-DB0.

        jb      Bit_Mode_16x4,LcdWriteSt_16x4     ; Если режим широкого шрифта 16x4.
        jb      Bit_Mode_12x4,LcdWriteSt_12x4    ; Если режим широкого шрифта 12x4.
        ;---------------------------------------;
        ljmp    LcdWriteSt_000                 ; Если режим обычного шрифта.
        ;*************************************;


         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 16x4. *********
       ;**********************************************************
LcdWriteSt_16x4:
        mov     A,POZITION ; Переменная POZITION определяет выбор: 0...7 -LCD левой матрицы
                          ;              8...15 (08H...0FH) LCD правой матрицы.
                         ;--------------------------------------------------------

        ;************************************************************************
        cjne    A,#08H,LcdWriteSt_Anal_16x4
LcdWriteSt_Anal_16x4:
        jc      LcdWriteSt_Left   ; Если позиция 0...7 для LCD левой матрицы
                                 ;
        ljmp    LcdWriteSt_Right; Если позиция 8...15 (08H...0FH) для LCD правой матрицы.
        ;----------------------;
        ;***********************************************************************



         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 12x4. *********
       ;**********************************************************
LcdWriteSt_12x4:
        mov     A,POZITION ; Переменная POZITION определяет выбор: 0...5 -LCD левой матрицы
                          ;              6...11 (06H...0BH) LCD правой матрицы.
                         ;--------------------------------------------------------

        ;************************************************************************
        cjne    A,#06H,LcdWriteSt_Anal_12x4
LcdWriteSt_Anal_12x4:
        jc      LcdWriteSt_Left   ; Если позиция 0...5 для LCD левой матрицы
                                 ;
        ljmp    LcdWriteSt_Right; Если позиция 6...11 (06H...0BH) для LCD правой матрицы.
        ;----------------------;
        ;***********************************************************************



         ;******** Если режим обычного шрифта. *************************************;
LcdWriteSt_000:
        mov     A,POZITION ; Переменная POZITION определяет выбор: 0...9 -LCD левой матрицы
                          ;              10...4-ре столбца левой+2 столбца LCD правой матрицы.
                         ;              11...20 (0BH...14H) LCD правой матрицы.
                        ;------------------------------------------------------------------------------

        ;************************************************************************
        cjne    A,#0AH,LcdWriteSt_Anal
LcdWriteSt_Anal:
        jc      LcdWriteSt_Left ; Если позиция 0...9 для LCD левой матрицы

        cjne    A,#0AH,LcdWriteSt_Right  ; Если позиция 11...20 (0BH...14H) для LCD правой матрицы.
        ;-------------------------------;
        ;***********************************************************************


        ;**** Если позиция 10: 4-ре столбца левой+2 столбца LCD правой матрицы. ************
        mov     A,R5    ; Анализ счётчика столбцов для 11-го знака.
                       ; (Счётчик в R5 работает в пп. LcdDataWriteSt и декрементируется
                      ;   после выхода из данной подпрограммы.
                     ;   Исходное состояние перед выводом первого столбца знака: R5:=6).**
        cjne    A,#3,ANAL_11_ZNAK_WR
ANAL_11_ZNAK_WR:
        jc      LcdWriteSt_Right ; Если столбец 5,6 11-го знака - для LCD правой матрицы.
                                ; ( R5 < 3 : -1...2).

        ljmp    LcdWriteSt_Left; Если столбец 1...4 11-го знака - для LCD левой матрицы.
                              ; ( R5 >= 3 : -6...3).
        ;******************************************************************************



         ;**************************************************************
        ; Если позиция 11...20 (0BH...14H) для LCD правой матрицы - обычный шрифт.
       ;               8...15 (08H...0FH) для LCD правой матрицы - широкий шрифт 16x4.
      ;               6...11 (06H...0BH) для LCD правой матрицы - широкий шрифт 12x4.
LcdWriteSt_Right:
        clr     CS1  ; Сбросить строб контроллера LCD левой матрицы.
        ;--
        setb    CS2  ; Установить строб контроллера LCD правой матрицы.
        setb    E1  ; Установить тактовый сигнал контроллера LCD левой и правой матрицы.
;;        ;-----------------;
;;        lcall   delay_10_mks
;;                        ; Задержка 10 мкс. (точнее: 9,765 мкс. Всего 18 циклов в пп.)
;;        ;--------------;
;;        lcall   delay_10_mks
;;                        ; Задержка 10 мкс. (точнее: 9,765 мкс. Всего 18 циклов в пп.)
;;        ;--------------;
;;;;;;        lcall   delay_10_mks
;;;;;                        ; Задержка 10 мкс. (точнее: 9,765 мкс. Всего 18 циклов в пп.)
;        nop
        ;--------------;
        clr     E1    ; Сбросить тактовый сигнал контроллера LCD левой и правой матрицы.
        clr     CS2  ; Сбросить строб контроллера LCD правой матрицы.
        ljmp    LcdWriteSt_Exit
        ;*************************************************************************


         ;**********************************************************************
        ; Если позиция 0...9 для LCD левой матрицы - обычный шрифт.
       ;              0...7  (00H...07H) для LCD левой матрицы - широкий шрифт 16x4.
      ;              0...5  (00H...05H) для LCD правой матрицы- широкий шрифт 12x4.
LcdWriteSt_Left:
        clr     CS2    ; Сбросить строб контроллера LCD правой матрицы.
        ;--
        setb    CS1  ; Установить строб контроллера LCD левой матрицы.
        setb    E1  ; Установить тактовый сигнал контроллера LCD левой и правой матрицы.
;;        ;-----------------;
;;        lcall   delay_10_mks
;;                        ; Задержка 10 мкс. (точнее: 9,765 мкс. Всего 18 циклов в пп.)
;;        ;--------------;
;;        lcall   delay_10_mks
;;                        ; Задержка 10 мкс. (точнее: 9,765 мкс. Всего 18 циклов в пп.)
;;        ;--------------;
;;;;;;        lcall   delay_10_mks
;;;;;                        ; Задержка 10 мкс. (точнее: 9,765 мкс. Всего 18 циклов в пп.)
;        nop
        ;--------------;
        clr     E1    ; Сбросить тактовый сигнал контроллера LCD левой и правой матрицы.
        clr     CS1  ; Сбросить строб контроллера LCD левой матрицы.

LcdWriteSt_Exit:
        ;*****************************************************************************
        pop    ACC
        ;--------------
        ret




;*************************************************************************
;=== 02.05.07 ===========================================================
; Чтение байта (ОЗУ или байта состояния) графического LCD (21 знак х 8 строк).
; Возврат:  ACC - считанное значение
;======================================================================
LcdReadSt:
        setb    R_W1
        ;******************************************;
        jb      Bit_Mode_16x4,LcdReadSt_16x4      ; Если режим широкого шрифта 16x4.
        jb      Bit_Mode_12x4,LcdReadSt_12x4     ; Если режим широкого шрифта 12x4.
        ;---------------------------------------;
        ljmp    LcdReadSt_000                  ; Если режим обычного шрифта.
        ;*************************************;


         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 16x4. *********
       ;**********************************************************
LcdReadSt_16x4:
        mov     A,POZITION ; Переменная POZITION определяет выбор: 0...7 -LCD левой матрицы
                          ;                          8...15 (08H...0FH) LCD правой матрицы.
                         ;---------------------------------------------------------------;

        ;******************************************************************************;
        cjne    A,#08H,LcdReadSt_Anal_16x4
LcdReadSt_Anal_16x4:
        jc      LcdReadSt_Left    ; Если позиция 0...7 для LCD левой матрицы
                                 ;
        ljmp    LcdReadSt_Right ; Если позиция 8...15 (08H...0FH) для LCD правой матрицы.
        ;----------------------;
        ;*************************************************************************;



         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 12x4. *********
       ;**********************************************************
LcdReadSt_12x4:
        mov     A,POZITION ; Переменная POZITION определяет выбор: 0...5 -LCD левой матрицы
                          ;                          6...11 (06H...0BH) LCD правой матрицы.
                         ;---------------------------------------------------------------;

        ;******************************************************************************;
        cjne    A,#06H,LcdReadSt_Anal_12x4
LcdReadSt_Anal_12x4:
        jc      LcdReadSt_Left    ; Если позиция 0...5 для LCD левой матрицы
                                 ;
        ljmp    LcdReadSt_Right ; Если позиция 6...11 (06H...0BH) для LCD правой матрицы.
        ;----------------------;
        ;*************************************************************************;



        ;******** Если режим обычного шрифта. *************************************;
LcdReadSt_000:
      ;**************************************************************************;
        mov     A,POZITION; Переменная POZITION определяет выбор:
                         ; 0...9  (00H...09H) LCD левой матрицы
                        ; 10...4-ре столбца левой+2 столбца LCD правой матрицы.
                       ; 11...20 (0BH...14H) LCD правой матрицы.
         ;----------------------------------------------------------------------
        cjne    A,#0AH,LcdReadSt_Anal
LcdReadSt_Anal:
        jc      LcdReadSt_Left ; Если позиция 0...9 для LCD левой матрицы

        cjne    A,#0AH,LcdReadSt_Right; Если позиция 11...20 (0BH...14H) для LCD правой матрицы.
        ;----------------------------;
         ;***********************************************************************



        ;**** Если позиция 10: 4-ре столбца левой+2 столбца LCD правой матрицы. ************
        mov     A,R5    ; Анализ счётчика столбцов для 11-го знака.
                       ; (Счётчик в R5 работает в пп. LcdDataWriteSt и декрементируется
                      ;   после выхода из данной подпрограммы.
                     ;   Исходное состояние перед выводом первого столбца знака: R5:=6).**
        cjne    A,#3,ANAL_11_ZNAK_RD
ANAL_11_ZNAK_RD:
        jc      LcdReadSt_Right ; Если столбец 5,6 11-го знака - для LCD правой матрицы.
                                ; ( R5 < 3 : -1...2).

        ljmp    LcdReadSt_Left; Если столбец 1...4 11-го знака - для LCD левой матрицы.
                              ; ( R5 >= 3 : -6...3).
        ;******************************************************************************




         ;************************************************************************
        ; Если позиция 11...20 (0BH...14H) для LCD правой матрицы - обычный шрифт.
       ;              8...15 (08H...0FH) для LCD правой матрицы - широкий шрифт.
LcdReadSt_Right:
        clr     CS1  ; Сбросить строб контроллера LCD левой матрицы.
        ;-----------;
        setb    CS2  ; Установить строб контроллера LCD правой матрицы.
        setb    E1  ; Установить тактовый сигнал контроллера LCD левой и правой матрицы.

        mov     P2,#0FFH
        mov     A,P2 ; Ввод байта в <A> с шины данных DB7-DB0.
;;        lcall   In_DB7_DB0
        ;**** Ввод байта в <A> с шины данных DB7-DB0. ****************
       ; Используемые регистры: C, ACC, R3, R7

        clr     E1    ; Сбросить тактовый сигнал контроллера LCD левой и правой матрицы.
        clr     CS2  ; Сбросить строб контроллера LCD правой матрицы.
        ljmp    LcdReadSt_Exit
        ;*************************************************************************

         ;************************************************************
        ; Если позиция 0...9 для LCD левой матрицы - обычный шрифт.
       ;              8...15 (08H...0FH) для LCD левой матрицы - широкий шрифт.
LcdReadSt_Left:	   //КАМАЗ
        clr     CS2  ; Сбросить строб контроллера LCD правой матрицы.
        ;-----------;
        setb    CS1  ; Установить строб контроллера LCD левой матрицы.
        setb    E1  ; Установить тактовый сигнал контроллера LCD левой и правой матрицы.
		
        mov     P2,#0FFH
        mov     A,P2 ; Ввод байта в <A> с шины данных DB7-DB0.
        
		
	
;;        lcall   In_DB7_DB0
        ;**** Ввод байта в <A> с шины данных DB7-DB0. ****************
       ; Используемые регистры: C, ACC, R3, R7
		
	
        clr     E1    ; Сбросить тактовый сигнал контроллера LCD левой и правой матрицы.
        clr     CS1  ; Сбросить строб контроллера LCD левой матрицы.
		
LcdReadSt_Exit:
        ;*****************************************************************************
        ret




; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
;========================================================================
LcdComWriteSt:
        mov     R6,A
LCWC_12:
 		lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LCWC_12
        mov     A,R6
        clr     R_S1
       ;===========;
        call    LcdWriteSt  ; Запись байта команды графического LCD (21 знак х 8 строк).
        ret
;===========================================================







;=== 30.05.08 =============================================================
; Запись знака в графический LCD (21 знак х 8 строк)    - обычный шрифт.
;                               (16 знаков х 4 строки) - широкий шрифт.
;               ИЛИ:            (12 знаков х 4 строки) - широкий шрифт.
;       Входной параметр: <A>: =записываемое значение в коде ASCII.
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; Используемые регистры: ACC, R0, R7, переменные: STB0...STB5.
;========================================================================
;**************************************************************************
; *** В режиме обычного шрифта: Bit_Mode_16x4:=0. *************************
; ***                          Bit_Mode_12x4:=0. **************************
; Инкрементирует переменную позиции знака POZITION, и при переполнении её,
; (POZITION > 20) - POZITION:=0 и, далее, инкрементирует переменную позиции
; строки для знака POZ_STR.
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================

; *** В режиме широкого шрифта 16х4: Bit_Mode_16x4:=1. ********************
; ***                               Bit_Mode_12x4:=0. *********************
; Инкрементирует переменную позиции знака POZITION, и при переполнении её,
; (POZITION > 15) - POZITION:=0 и, далее, инкрементирует переменную позиции
; строки для знака POZ_STR.
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================

; *** В режиме широкого шрифта 12х4: Bit_Mode_16x4:=0. ********************
; ***                               Bit_Mode_12x4:=1. *********************
; Инкрементирует переменную позиции знака POZITION, и при переполнении её,
; (POZITION > 11) - POZITION:=0 и, далее, инкрементирует переменную позиции
; строки для знака POZ_STR.
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
LcdDataWriteSt:
        push    ACC
        ;---------
        push    DPH
        push    DPL
        ;--------------
        lcall   LcdTrans
        ; Кодировщик символьной таблицы графического индикатора 128х64 точки
       ; Формат знака 5х7 пикселей (плюс 6-ой "пустой" столбец и 8-я "пустая" строка).
      ; ** Входной параметр: <A>: = ASCII код знака.
     ; ***************************************************************************
    ; Возврат: STB0...STB5:=Шесть байтов кодов столбцов знака графич. индикатора.
   ;============================================================================

;;LDW_DATA_12:
;;        lcall   LcdIsBusySt     ; Проверка занятости индикатора
;;        jc      LDW_DATA_12    ;$-3
;;        ;---------------------;
        mov     IZMST,POZITION ; Временное хранение данных переменной текущего номера
                              ; знакоместа, на случай режима выделения рамкой.
        mov     IZMML,POZ_STR  ; Временное хранение данных переменной текущего номера
                              ; строки, на случай режима выделения рамкой.
         ;******************************************************************************


        mov     R0,#STB0; Переменные для хранения кодов
                       ; столбцов знака графич. индикатора
                      ; физически в оперативной памяти
                     ; распределяются подряд:
                    ; STB0...STB5. Загружаются кодами
                   ; столбцов знака после пп. LcdTrans.
                  ;-----------------------------------
        mov     R5,#6 ; Установить счётчик столбцов.
        ;------------;

        jnb     Bit_Mode_16x4,LcdDataWriteSt_Anal_12x4
                                        ; Если НЕ режим широкого шрифта 16x4.
         ;!! *** 29-05-2008 !!! *****************************************************
        ;!! Анализ битового признака режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.

        ljmp    LcdDataWriteSt_Cukl_16x4_000 ; Если режим широкого шрифта 16x4.
     ;************************************************************************


LcdDataWriteSt_Anal_12x4:
        jnb     Bit_Mode_12x4,LcdDataWriteSt_Cukl; Если режим обычного шрифта.
                                                ; НЕ режим широкого шрифта 16x4
                                               ; и НЕ режим широкого шрифта 12x4.
         ;!! *** 03-06-2008 !!! *******************************************
        ;!! Анализ битового признака режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 12 символов х 4 строки
                              ; формат знака 8х14 пикселей.


        ljmp    LcdDataWriteSt_Cukl_12x4_000 ; Если режим широкого шрифта 12x4.
     ;************************************************************************


          ;****************************;
         ; Если режим обычного шрифта.;
        ;****************************;
LcdDataWriteSt_Cukl:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_Cukl
       ;=====================;
        setb    R_S1        ;
       ;===================;
        mov     A,@R0
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
        inc     R0        ; Непосредственно символ: 5х7 пикселей;
                         ; Реальная область записи символа: 6х8 пикселей.

        djnz    R5,LcdDataWriteSt_Cukl
        ;------------------------------------------------------------;

        ;------------------;
        inc     POZITION  ;  Инкремент переменной позиции знака.
        ;----------------;
        mov     A,POZITION
        cjne    A,#15H,LcdDataWriteSt_Exit ; Если переменная позиции знака не переполнилась.

        ; Если переменная позиции знака ПЕРЕПОЛНИЛАСЬ !!!.
        mov     POZITION,#00H
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;========================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой матрицы" ===============
     ;===========================================================================================

        mov     POZITION,#0BH
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                    ; Параметр поправки при адресации столбца LCD правой матрицы.
     ;!!! Здесь ИМЕННО такой параметр поправки: POPRAVKA_LEFT_LCD (EQU 00H), т.к. если
    ;!!! имеется начальная позиция 0 для LCD левой матрицы, если переменная позиции знака
   ;!!! переполнилась, то при последующем выводе 10-го знака в новой строке - последние его
  ;!!! два столбца (из 6-ти) должны выводиться, в пп. LcdWriteSt в начальные два столбца
 ;!!! LCD правой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;========================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - правой матрицы" ========
     ;========================================================================

  ;*************************************************************************
 ;*************************************************************************
        ;------------------;
        inc     POZ_STR   ; Инкремент переменной позиции строки для знака.
        ;----------------;
        mov     A,POZ_STR
        cjne    A,#8,LcdDataWriteSt_Obxod
                                ; Если переменная позиции строки для знака не переполнилась.

        ; Если переменная позиции строки для знака ПЕРЕПОЛНИЛАСЬ !!!.
        mov     POZ_STR,#00H
        ;-------------------
        ;= Команда "Установить страницу 0 ОЗУ LCD - левой/правой матрицы" ======

LcdDataWriteSt_Obxod:
        mov     POZITION,#00H
        ;-------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;========================================================================
      ;= Команда "Установить следующую страницу ОЗУ LCD - левой матрицы" ======


        mov     POZITION,#0BH
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;========================================================================
      ;= Команда "Установить следующую страницу ОЗУ LCD - правой матрицы" ======

        mov     POZITION,#00H
 ;*************************************************************************
 ;*************************************************************************
        ;------------------------------------------------------------------
LcdDataWriteSt_Exit:
        mov     A,PR_VIDELEN  ; Анализ признака выделения выводимых знаков
        cjne    A,#2,ANALIZ_PR_VID_A
ANALIZ_PR_VID_A:
        jc      LcdDataWriteSt_Exit_NEW ; Если признак выделения < 2.
        ;**************************************************************


         ;***  Если признак выделения =2..3. *****
         ;*********************************************************************************
        mov     UKAZ_KUR_MENU,POZITION
                                ; Временное хранение данных переменной установленого номера
                               ; знакоместа.
        ;************************;
        mov     IZMSR,POZ_STR ; Временное хранение данных переменной установленого номера
                             ; строки.
         ;******************************************************************************
;;        cjne    A,#2,ANALIZ_PR_VID_B ; Если признак выделения =3.


         ;** Если признак выделения =2. ****************************
        ;** Был встречен первый символ для выделения "рамкой" *****
       ;**********************************************************
        mov     POZITION,IZMST ; Восстановление данных переменной текущего номера
                              ; знакоместа - до инкрементирования.
        mov     POZ_STR,IZMML; Восстановление данных переменной текущего номера
                            ; строки - до инкрементирования.
         ;******************************************************************************
;        dec     POZITION
;        ;---------------------;
;        lcall   SET_POZITION
        ;*******************;
;        mov     A,#0FEH    ; Символ "левая сторона рамки выделения"
;        lcall   OUT_RAMKA ; Вывод символа "левая сторона рамки выделения"
;        ;----------------;
;;        mov     PR_VIDELEN,#3 ; Установить признак выделения в состояние
;;                             ; для последующего выделения рамкой
;;                            ; следующих знаков. **********************
;        ;------------------;
;        inc     POZITION  ;
        ;****************;
        ljmp    ANALIZ_PR_VID_B_000
        ;*********************;


;;    ;** Если признак выделения =3. **************************************************
;;   ;** Были встречены последующие после первого символы для выделения "рамкой". ****
;;  ;********************************************************************************
;;ANALIZ_PR_VID_B:
;;        mov     POZITION,IZMST ; Восстановление данных переменной текущего номера
;;                              ; знакоместа - до инкрементирования.
;;        mov     POZ_STR,IZMML; Восстановление данных переменной текущего номера
                            ; строки - до инкрементирования.
         ;******************************************************************************
ANALIZ_PR_VID_B_000:
;;        ;**********************;
;;        dec     POZ_STR       ;
;        lcall   SET_POZITION ;
;;        ;*******************;
;;        mov     A,#0FFH    ; Символ "верхняя сторона рамки выделения"
;;        lcall   OUT_RAMKA ; Вывод символа "верхняя сторона рамки выделения"
        ;----------------;

        ;***********************;
;;        inc     POZ_STR        ;
        inc     POZ_STR       ;
        lcall   SET_POZITION ;
        ;*******************;
        mov     A,#0FDH    ; Символ "нижняя сторона рамки выделения"
        lcall   OUT_RAMKA ; Вывод символа "нижняя сторона рамки выделения"
        ;----------------;


         ;*****************************************************************************
        mov     POZITION,UKAZ_KUR_MENU
                                ; Восстановление данных переменной установленого номера
                               ; знакоместа.
        mov     POZ_STR,IZMSR  ; Восстановление данных переменной установленого номера
                              ; строки.
        ;********************;
        lcall   SET_POZITION;
         ;**************************************************************************
LcdDataWriteSt_Exit_NEW:
        ;---------
        pop     DPL
        pop     DPH
        ;--------------
        pop    ACC
        ;--------------
        ret
;**************************************************************************



  ;***************************************************************************************
 ;** Вспомогательная подпрограмма вывода символа рамки. (входит в пп. LcdDataWriteSt) ***
;***************************************************************************************
OUT_RAMKA:
        lcall   LcdTrans
        ; Кодировщик символьной таблицы графического индикатора 128х64 точки
       ; Формат знака 5х7 пикселей (плюс 6-ой "пустой" столбец и 8-я "пустая" строка).
      ; ** Входной параметр: <A>: = ASCII код знака.
     ; ***************************************************************************
    ; Возврат: STB0...STB5:=Шесть байтов кодов столбцов знака графич. индикатора.
   ;============================================================================
        mov     R0,#STB0; Переменные для хранения кодов
                       ; столбцов знака графич. индикатора
                      ; физически в оперативной памяти
                     ; распределяются подряд:
                    ; STB0...STB5. Загружаются кодами
                   ; столбцов знака после пп. LcdTrans.
                  ;-----------------------------------
        mov     R5,#6 ; Установить счётчик столбцов.
        ;------------;
        ;---------------------;
LcdDataWriteSt_Cukl_Ramka:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_Cukl_Ramka
       ;=====================;
        setb    R_S1        ;
       ;===================;
        mov     A,@R0
        call    LcdWriteSt; Запись по столбцам графического символа LCD.
        inc     R0       ; Непосредственно символ: 5х7 пикселей;
                        ; Реальная область записи символа: 6х8 пикселей.

        djnz    R5,LcdDataWriteSt_Cukl_Ramka
        ;------------------------------------------------------------;
        ret
;********************************************************************




            ;***************************************************************
           ;*** Вариации пп. LcdDataWriteSt для режимов широкого шрифта ***
          ;*** 12х4 и 16х4. !!!! *****************************************

         ;**********************************************************
        ;*** 03-06-2008  Если режим широкого шрифта 12x4. *********
       ;*** Повтор записи данных столбца:
      ;*** для STB0 или STB0+2 или STB0+4 или STB0+5.
     ;**********************************************************
Repeat_Write_Str_12x4:
         ;***************************************************************************
        ; 1.1. Установка адреса строки графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        inc     B
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 1.1а. Установка адреса столбца графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt


        ; 1.1б. Повтор записи данных столбца графического индикатора для
       ; страницы ОЗУ LCD - n+1
      ; для STB0 или STB0+2 или STB0+4 или STB0+5.
        ;-----------------------;
LcdDataWriteSt_12x4_Pr_Zan_C:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_12x4_Pr_Zan_C
        ;==============================
        mov     A,DPH
       ;======================;
        setb    R_S1         ;
       ;====================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 8х14 пикселей;
                         ; Реальная область записи символа: 10х16 пикселей.
        ;***************************************************************************

         ;**************************************************************************
        ; 2.1. Установка адреса строки графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знак х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 2.1а. Установка адреса столбца графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt
  ;========================================================================================

        ; 2.1б. Повтор записи данных столбца графического индикатора для
       ; страницы ОЗУ LCD  - n
      ; для STB0 или STB0+2 или STB0+4 или STB0+5.
LcdDataWriteSt_12x4_Pr_Zan_D:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_12x4_Pr_Zan_D
        ;==============================
        mov     A,DPL
       ;======================;
        setb    R_S1         ;
       ;====================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 8х14 пикселей;
                         ; Реальная область записи символа: 10х16 пикселей.
        ;***********;
        inc     SLC;  Инкремент адреса столбца, первоначально вычисленный
       ;**********; в пп. SET_POZITION.
        anl     SLC,#3FH ;
        orl     SLC,#40H;
        ;**************;

        ;*****************************************************************************
        ljmp    Analiz_12x4_Exit
        ;***************************************************************************



         ;**********************************************************
        ;*** 03-06-2008  Если режим широкого шрифта 12x4. *********
       ;**********************************************************
LcdDataWriteSt_Cukl_12x4_000:
        anl     POZ_STR,#06H    ; Переменная позиции строки в
                               ; режиме широкого шрифта должна
                              ; быть только ЧЁТНОЙ, и принимать
                             ; 4-ре исходных значения: 0, 2, 4, 6.
                            ;************************************
        anl     POZITION,#0FH; Переменная позиции знака в режиме
                            ; широкого шрифта может принимать
                           ; значения только: 0...15.
        ;*****************;
LcdDataWriteSt_Cukl_12x4:
        ;--------------------------------------------------------------
        mov     A,@R0
        lcall   Obrabot_12x4
                         ; Обработка данных столбца графического
                        ; индикатора - преобразование в двухбайтовый
                       ; формат, для вывода их на индикатор, в режиме
                      ; широкого шрифта 12х4, в страницы ОЗУ LCD: n и n+1.
                     ; Исходные данные столбца в <A>.
                    ;-------------------------------------------------
                   ; Возврат: в <DPTR> преобразованные в двухбайтовый
                  ; формат данные столбца столбца графического индикатора:
                 ; DPH - данные столбца графического индикатора для
                ; страницы ОЗУ LCD - n+1.
               ; DPL - данные столбца графического индикатора для
              ; страницы ОЗУ LCD - n.
             ;**************************************************

         ;***************************************************************************
        ; 1. Установка адреса строки графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        inc     B
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 1а. Установка адреса столбца графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt


        ; 1б. Запись данных столбца графического индикатора для
       ; страницы ОЗУ LCD - n+1.
        ;-----------------------;
LcdDataWriteSt_12x4_Pr_Zan_A:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_12x4_Pr_Zan_A
        ;==============================
        mov     A,DPH
       ;=====================;
        setb    R_S1        ;
       ;===================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 8х14 пикселей;
                         ; Реальная область записи символа: 10х16 пикселей.
        ;***************************************************************************

         ;**************************************************************************
        ; 2. Установка адреса строки графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 2а. Установка адреса столбца графического LCD (12 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt

  ;========================================================================================

        ; 2б. Запись данных столбца графического индикатора для
       ; страницы ОЗУ LCD  - n.
LcdDataWriteSt_12x4_Pr_Zan_B:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_12x4_Pr_Zan_B
        ;==============================
        mov     A,DPL
       ;=====================;
        setb    R_S1        ;
       ;===================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 8х14 пикселей;
                         ; Реальная область записи символа: 10х16 пикселей.
        ;***************************************************************************

        ;***********;
        inc     SLC;  Инкремент адреса столбца, первоначально вычисленный
       ;**********;  в пп. SET_POZITION.
        anl     SLC,#3FH ;
        orl     SLC,#40H;
        ;**************;

         ;**************************************************************************
        ;*** Анализ номеров столбцов: нужен ли повтор записи данных столбца *******
       ;*** в ОЗУ LCD. ***********************************************************
        mov     A,R0
        ;----------
        cjne    A,#STB0,Analiz_12x4_B
        ljmp    Repeat_Write_Str_12x4
        ;*******************************

Analiz_12x4_B:
        cjne    A,#STB0+2,Analiz_12x4_C
        ljmp    Repeat_Write_Str_12x4
        ;*******************************

Analiz_12x4_C:
        cjne    A,#STB0+4,Analiz_12x4_D
        ljmp    Repeat_Write_Str_12x4
        ;*******************************

Analiz_12x4_D:
        cjne    A,#STB0+5,Analiz_12x4_Exit
        ljmp    Repeat_Write_Str_12x4
        ;*******************************

Analiz_12x4_Exit:
        inc     R0
        djnz    R5,LcdDataWriteSt_Cukl_12x4
        ;------------------------------------------------------------;

         ;*******************************************************
        ;------------------;
        inc     POZITION  ;  Инкремент переменной позиции знака.
        ;----------------;
        mov     A,POZITION
        cjne    A,#0CH,LcdDataWriteSt_Exit_12x4 ; Если переменная позиции знака не переполнилась.

        ; Если переменная позиции знака ПЕРЕПОЛНИЛАСЬ !!!.
        mov     POZITION,#00H
        mov     A,#40H
        add     A,#4 ; Для широкого шрифта 12х4. 03-06-2008.
        ;-------------------------------------------------

;;;;;;        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
;;;;                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
;+++ 02-06-2008 ++++++++++;
        mov     SLC,A    ; Сохранить вычисленный адрес столбца в промежуточной
                        ; переменной для использования в пп. LcdDataWriteSt,
;+++ 02-06-2008 +++++++; в режиме широкого шрифта.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой матрицы" ===============
     ;===========================================================================================

        mov     POZITION,#06H
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                    ; Параметр поправки при адресации столбца LCD правой матрицы.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - правой матрицы" ========
     ;========================================================================

  ;*************************************************************************
 ;*************************************************************************
        ;------------------;
        inc     POZ_STR   ; Инкремент переменной позиции строки для знака.
        ;----------------;
        mov     A,POZ_STR
        anl     A,#01H
        ;-------------
        jnz     DopIncr_12x4

        ;!!! "Аварийная ситуация" !!!
        ljmp    LcdDataWriteSt_Obxod_12x4

DopIncr_12x4:
        inc     POZ_STR
        ;----------------------;
LcdDataWriteSt_Obxod_12x4:
        anl     POZ_STR,#06H
        ;-------------------;
        ;------------------;
        ;= Команда "Установить страницу 0 ОЗУ LCD - левой/правой матрицы" ======
        mov     POZITION,#00H
        ;-------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить следующую страницу ОЗУ LCD - левой матрицы" ======


        mov     POZITION,#06H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить следующую страницу ОЗУ LCD - правой матрицы" ======


        ;--------------------
        mov     POZITION,#00H
 ;*************************************************************************
 ;*************************************************************************
        ;------------------------------------------------------------------
LcdDataWriteSt_Exit_12x4:
        ljmp    LcdDataWriteSt_Exit_NEW
        ;******************************





;**********************************************************************







         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 16x4. *********
       ;*** Повтор записи данных столбца (для STB0+2 или STB0+5).
      ;**********************************************************
Repeat_Write_Str_16x4:
         ;***************************************************************************
        ; 1.1. Установка адреса строки графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        inc     B
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 1.1а. Установка адреса столбца графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt


        ; 1.1б. Повтор записи данных столбца графического индикатора для
       ; страницы ОЗУ LCD - n+1 (для STB0+2 или STB0+5).
        ;-----------------------;
LcdDataWriteSt_16x4_Pr_Zan_C:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_16x4_Pr_Zan_C
        ;==============================
        mov     A,DPH
       ;======================;
        setb    R_S1         ;
       ;====================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 6х14 пикселей;
                         ; Реальная область записи символа: 8х16 пикселей.
        ;***************************************************************************

         ;**************************************************************************
        ; 2.1. Установка адреса строки графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 2.1а. Установка адреса столбца графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt
  ;========================================================================================

        ; 2.1б. Повтор записи данных столбца графического индикатора для
       ; страницы ОЗУ LCD  - n (для STB0+2 или STB0+5).
LcdDataWriteSt_16x4_Pr_Zan_D:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_16x4_Pr_Zan_D
        ;==============================
        mov     A,DPL
       ;======================;
        setb    R_S1         ;
       ;====================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 6х14 пикселей;
                         ; Реальная область записи символа: 8х16 пикселей.
        ;***********;
        inc     SLC;  Инкремент адреса столбца, первоначально вычисленный
       ;**********; в пп. SET_POZITION.
        anl     SLC,#3FH ;
        orl     SLC,#40H;
        ;**************;

        ;*****************************************************************************
        ljmp    Analiz_16x4_Exit
        ;***************************************************************************



         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 16x4. *********
       ;**********************************************************
LcdDataWriteSt_Cukl_16x4_000:
        anl     POZ_STR,#06H    ; Переменная позиции строки в
                               ; режиме широкого шрифта должна
                              ; быть только ЧЁТНОЙ, и принимать
                             ; 4-ре исходных значения: 0, 2, 4, 6.
                            ;************************************
        anl     POZITION,#0FH; Переменная позиции знака в режиме
                            ; широкого шрифта может принимать
                           ; значения только: 0...15.
        ;*****************;
LcdDataWriteSt_Cukl_16x4:
        ;--------------------------------------------------------------
        mov     A,@R0
                             ;*** !!! 04-06-2008 !!! ************************
        lcall   Obrabot_12x4; Принят вариант: "растянуть" знак по вертикали
                           ; в два раза длинней - было 7 пикселей, стало 14.
                          ;************************************************
                         ; Обработка данных столбца графического
                        ; индикатора - преобразование в двухбайтовый
                       ; формат, для вывода их на индикатор, в режиме
                      ; широкого шрифта 12х4, в страницы ОЗУ LCD: n и n+1.
                     ; Исходные данные столбца в <A>.
                    ;-------------------------------------------------
                   ; Возврат: в <DPTR> преобразованные в двухбайтовый
                  ; формат данные столбца столбца графического индикатора:
                 ; DPH - данные столбца графического индикатора для
                ; страницы ОЗУ LCD - n+1.
               ; DPL - данные столбца графического индикатора для
              ; страницы ОЗУ LCD - n.
             ;**************************************************

         ;***************************************************************************
        ; 1. Установка адреса строки графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        inc     B
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 1а. Установка адреса столбца графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n+1.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt


        ; 1б. Запись данных столбца графического индикатора для
       ; страницы ОЗУ LCD - n+1.
        ;-----------------------;
LcdDataWriteSt_16x4_Pr_Zan_A:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_16x4_Pr_Zan_A
        ;==============================
        mov     A,DPH
       ;=====================;
        setb    R_S1        ;
       ;===================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 6х14 пикселей;
                         ; Реальная область записи символа: 8х16 пикселей.
        ;***************************************************************************

         ;**************************************************************************
        ; 2. Установка адреса строки графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        ;+++++++++++++++
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;======================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой/правой матрицы"
     ;= данными из переменной POZ_STR. ======================================================
    ;=======================================================================================

        ; 2а. Установка адреса столбца графического LCD (16 знаков х 4 строки)
       ; для страницы ОЗУ LCD - n.
;+++ 02-06-2008 ++++++++++;
        mov     A,SLC    ; Извлечь адрес столбца, первоначально вычисленный
                        ; в пп. SET_POZITION.
;+++ 02-06-2008 +++++++;
        lcall   LcdComWriteSt

  ;========================================================================================

        ; 2б. Запись данных столбца графического индикатора для
       ; страницы ОЗУ LCD  - n.
LcdDataWriteSt_16x4_Pr_Zan_B:
        lcall   LcdIsBusySt    ; Проверка занятости индикатора
        jc      LcdDataWriteSt_16x4_Pr_Zan_B
        ;==============================
        mov     A,DPL
       ;=====================;
        setb    R_S1        ;
       ;===================;
        lcall    LcdWriteSt; Запись по столбцам графического символа LCD.
                          ; Непосредственно символ: 6х14 пикселей;
                         ; Реальная область записи символа: 8х16 пикселей.
        ;***************************************************************************

        ;***********;
        inc     SLC;  Инкремент адреса столбца, первоначально вычисленный
       ;**********;  в пп. SET_POZITION.
        anl     SLC,#3FH ;
        orl     SLC,#40H;
        ;**************;

         ;**************************************************************************
        ;*** Анализ номеров столбцов: нужен ли повтор записи данных столбца *******
       ;*** в ОЗУ LCD. ***********************************************************
        mov     A,R0
        ;----------
        cjne    A,#STB0+2,Analiz_16x4_B
        ljmp    Repeat_Write_Str_16x4
        ;*******************************

Analiz_16x4_B:
        cjne    A,#STB0+5,Analiz_16x4_Exit
        ljmp    Repeat_Write_Str_16x4
        ;*******************************

Analiz_16x4_Exit:
        inc     R0
        djnz    R5,LcdDataWriteSt_Cukl_16x4
        ;------------------------------------------------------------;

         ;*******************************************************
        ;------------------;
        inc     POZITION  ;  Инкремент переменной позиции знака.
        ;----------------;
        mov     A,POZITION
        cjne    A,#10H,LcdDataWriteSt_Exit_16x4 ; Если переменная позиции знака не переполнилась.

        ; Если переменная позиции знака ПЕРЕПОЛНИЛАСЬ !!!.
        mov     POZITION,#00H
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
;+++ 02-06-2008 ++++++++++;
        mov     SLC,A    ; Сохранить вычисленный адрес столбца в промежуточной
                        ; переменной для использования в пп. LcdDataWriteSt,
;+++ 02-06-2008 +++++++; в режиме широкого шрифта.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой матрицы" ===============
     ;===========================================================================================

        mov     POZITION,#08H
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                    ; Параметр поправки при адресации столбца LCD правой матрицы.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - правой матрицы" ========
     ;========================================================================

  ;*************************************************************************
 ;*************************************************************************
        ;------------------;
        inc     POZ_STR   ; Инкремент переменной позиции строки для знака.
        ;----------------;
        mov     A,POZ_STR
        anl     A,#01H
        ;-------------
        jnz     DopIncr_16x4

        ;!!! "Аварийная ситуация" !!!
        ljmp    LcdDataWriteSt_Obxod_16x4

DopIncr_16x4:
        inc     POZ_STR
        ;----------------------;
LcdDataWriteSt_Obxod_16x4:
        anl     POZ_STR,#06H
        ;-------------------;
        ;------------------;
        ;= Команда "Установить страницу 0 ОЗУ LCD - левой/правой матрицы" ======
        mov     POZITION,#00H
        ;-------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить следующую страницу ОЗУ LCD - левой матрицы" ======


        mov     POZITION,#08H
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;========================================================================
      ;= Команда "Установить следующую страницу ОЗУ LCD - правой матрицы" ======


        ;--------------------
        mov     POZITION,#00H
 ;*************************************************************************
 ;*************************************************************************
        ;------------------------------------------------------------------
LcdDataWriteSt_Exit_16x4:
        ljmp    LcdDataWriteSt_Exit_NEW
        ;******************************





;**********************************************************************

;=== 10.04.07 ====================================================
; Проверка состояния занятости или(и) сброса графического
; LCD левой или правой матрицы (20 знаков х 1-8 строк).
; Возврат: C = 0 - LCD свободен и нет состояния сброса.
;          C = 1 - LCD занят, или(и) есть состояние сброса.
; Используемые регистры: ACC, R7
;===============================================================
LcdIsBusySt:
        clr     R_S1
       ;===========;
        call    LcdReadSt
        jb      ACC.7,ZANIAT           ; Если установлен флаг занятости индикатора.
        jb      ACC.4,RESET_LCD       ; Если есть состояние сброса индикатора.
        clr     C
        ret
ZANIAT:
        
		rlc     A
        ret
        NOP
		NOP
		NOP
		
		;***********************;
RESET_LCD:
        rlc     A
        rlc     A
        rlc     A
        ljmp    ZANIAT
;**********************************************************************




 ;************   Отладочная подпрограмма вывода на индикатор байта <A> ****
;************   в шестнадцатиричном коде. ********************************
LCD_OUTH:       PUSH    ACC     ; ВЫВОД 2-Х ШЕСТНАДЦАТИРИЧНЫХ ЦИФР ИЗ <A>.
				; НА ИНДИКАТОР.
		RR	A
		RR	A
		RR	A
		RR	A
                LCALL   LCD_OUTH0  ; Вывод старшей шестнадцатиричной цифры.
                POP     ACC       ;
                ;----------------;
                PUSH    ACC     ;
                LCALL   LCD_OUTH0  ; Вывод младшей шестнадцатиричной цифры.
                POP     ACC   ;
                ;------------;

;                PUSH    ACC
;                MOV     A,#' '    ; Вывод "пробела" (20H).
;                LCALL   LcdDataWriteSt
;                POP     ACC
                ;---------;
                RET

LCD_OUTH0:      ANL     A,#0FH
		MOV	B,A
		CLR	C	; C:=0.
		SUBB	A,#0AH	; A:= <A>-0AH.
		JC	IOUTH1	; ЕСЛИ БАЙТ 0AH > (A)

		; ЕСЛИ БАЙТ 0AH <= <A>.
		MOV	A,B
		ADD	A,#37H	; A:= A+37H
		LJMP	IOUTH2

IOUTH1:		MOV	A,B
		ORL	A,#30H
IOUTH2:         LCALL   LcdDataWriteSt
		RET
;****




        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
SET_POZITION:
          ;*****************************************************************
         lcall   LcdStrWriteSt_serialBufer_Sm_An
        ;*** Обработка параметров позиции строки и количества символов ***
       ;*** в случае режима широкого шрифта 16 символов х 4 строки.   ***
      ;*****************************************************************
        jb      Bit_Mode_16x4,SET_POZITION_16x4_000 ; Если режим широкого шрифта 16х4.

        jb      Bit_Mode_12x4,SET_POZITION_12x4 ; Если режим широкого шрифта 12х4.

        ljmp    SET_POZITION_000               ; Если режим обычного шрифта 21x8.
        ;*************************************;


        ;****************************************;
SET_POZITION_16x4_000:                          ;
        ljmp    SET_POZITION_16x4              ; Если режим широкого шрифта 16х4.
        ;*************************************;


         ;**********************************************************
        ;*** 03-06-2008  Если режим широкого шрифта 12x4. *********
       ;**********************************************************
SET_POZITION_12x4:
        ;*****************;
        mov     zp_st,POZITION; Временное хранение данных переменной начального номера
                             ; знакоместа.
                            ; Переменная zp_st для определения начальной строки вывода символа.
        mov     zp_ml,POZITION; Временное хранение данных переменной начального номера
                             ; знакоместа.
                            ; Переменная zp_ml для восстановления данных переменной
                           ; начального номера знакоместа после выхода из пп. SET_POZITION.

        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...5 -LCD левой матрицы;
                         ;                    6...11 (06H...0BH) LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой матрицы"
     ;= данными из переменной POZ_STR. ===============================================

        mov     POZITION,#06H; Установить позицию "6" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...5 -LCD левой матрицы;
                          ;                    6...11 (06H...0BH) LCD правой матрицы.
                         ;-----------------------------------------------------------
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - правой матрицы"
     ;= данными переменной POZ_STR. ==================================================
    ;================================================================================


         ;*************************************************************************
        ;- 2. Установка требуемого начального знакоместа 0...11 (00H...0BH).
       ;*************************************************************************
      ; К данному моменту, в переменной zp_st находятся данные начального адреса
     ; знакоместа: POZITION. **************************************************
    ; (zp_st:= POZITION)    **************************************************

        mov     A,zp_st   ; Переменная zp_st(в ней данные POZITION) определяет выбор:
                         ; 0...5 -LCD левой матрицы
                        ; 6...11 (06H...0BH) LCD правой матрицы.
                       ;-----------------------------------------------------------
        cjne    A,#06H,SET_POZITION_Anal_12x4
SET_POZITION_Anal_12x4:
        jc      SET_POZITION_Left_12x4 ; Если позиция 0...5 для LCD левой матрицы.

         ;************************************************************************
        ; Если позиция 6...11 (06H...0BH) для LCD правой матрицы.
SET_POZITION_Right_12x4:
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...5 -LCD левой матрицы
                         ;       6...11 (06H...0BH) -LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;=============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой матрицы" ==============
     ;=============================================================================


        mov     POZITION,#06H; Установить позицию "6" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...5 -LCD левой матрицы
                          ;      6...11 (06H...0BH) LCD правой матрицы.
                         ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
;;        add     A,#POPRAVKA_RIGHT_LCD; (EQU 02H)
        mov     B,A                 ; Параметр поправки при адресации столбца LCD правой матрицы.
         ;-------------------------;
        ; К данному моменту, в переменной zp_st находятся данные начального адреса
       ; знакоместа: POZITION. **************************************************
      ; (zp_st:= POZITION)    **************************************************

 ;------ 11.05.2007 !!!------------------------------
        clr     C       ; C:=0.
        mov     A,zp_st
        subb    A,#06H
        mov     zp_st,A ; zp_st:= zp_st-6.
        ; Коррекция данных начального адреса
       ; знакоместа (POZITION), для обеспечения
      ; корректного определения адреса столбца -
     ; - знакоместа LCD - правой матрицы,
    ; в соответствии с адресом переменной POZITION.
;------ 11.05.2007 !!!----------------------------

;;        mov     A,zp_st ;??? Нужна ли эта команда ???
        jz      Right_CUKL_End_12x4
        ;--------------------
SET_POZITION_Right_CUKL_12x4:
        mov     A,#10
        add     A,B
        mov     B,A
        ;----------
        djnz    zp_st,SET_POZITION_Right_CUKL_12x4

Right_CUKL_End_12x4:
        mov     A,B
;+++ 02-06-2008 ++++++++++;
        mov     SLC,A    ; Сохранить вычисленный адрес столбца в промежуточной
                        ; переменной для использования в пп. LcdDataWriteSt,
;+++ 02-06-2008 +++++++; в режиме широкого шрифта.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;==============================================================================
      ;= Команда "Установить требуемый адрес столбца (знакоместо) LCD - правой матрицы
     ;= данными в соответствии с адресом переменной POZITION.
    ;==============================================================================

       ;==============================================================================
        anl     POZ_STR,#06H    ; Переменная позиции строки в
                               ; режиме широкого шрифта должна
                              ; быть только ЧЁТНОЙ, и принимать
                             ; 4-ре исходных значения: 0, 2, 4, 6.
                            ;************************************
        anl     zp_ml,#0FH   ; Переменная позиции знака в режиме
                            ; широкого шрифта может принимать
                           ; значения только: 0...15.

        ljmp    SET_POZITION_EXIT
         ;***********************************************************************



         ;***********************************************************************
        ; Если позиция 0...5 для LCD левой матрицы.
SET_POZITION_Left_12x4:
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...5 -LCD левой матрицы
                         ;      6...11 (06H...0BH) LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#4 ; Для широкого шрифта 12х4. 03-06-2008.
        ;-------------------------------------------------
;;;        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
;;;                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
        mov     B,A
         ;-----------------------;
        ; К данному моменту, в переменной zp_st находятся данные начального адреса
       ; знакоместа: POZITION. **************************************************
      ; (zp_st:= POZITION)    **************************************************
        mov     A,zp_st
        jz      Left_CUKL_End_12x4
        ;--------------------
SET_POZITION_Left_CUKL_12x4:
        mov     A,#10
        add     A,B
        mov     B,A
        ;----------
         djnz    zp_st,SET_POZITION_Left_CUKL_12x4

Left_CUKL_End_12x4:
        mov     A,B
;+++ 02-06-2008 ++++++++++;
        mov     SLC,A    ; Сохранить вычисленный адрес столбца в промежуточной
                        ; переменной для использования в пп. LcdDataWriteSt,
;+++ 02-06-2008 +++++++; в режиме широкого шрифта.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков х 4 строки).
       ;==============================================================================
      ;= Команда "Установить требуемый адрес столбца (знакоместо) LCD - левой матрицы
     ;= данными в соответствии с адресом переменной POZITION.
    ;==============================================================================


        mov     POZITION,#06H; Установить позицию "6" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...5 -LCD левой матрицы
                          ;       6...11 (06H...0BH) LCD правой матрицы.
                         ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                    ; Параметр поправки при адресации столбца LCD правой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (12 знаков 4 строки).
       ;=============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - правой матрицы" =============
     ;=============================================================================

       ;==============================================================================
        anl     POZ_STR,#06H    ; Переменная позиции строки в
                               ; режиме широкого шрифта должна
                              ; быть только ЧЁТНОЙ, и принимать
                             ; 4-ре исходных значения: 0, 2, 4, 6.
                            ;************************************
        anl     zp_ml,#0FH   ; Переменная позиции знака в режиме
                            ; широкого шрифта может принимать
                           ; значения только: 0...15.

        ljmp    SET_POZITION_EXIT
        ;=======================================================================



         ;**********************************************************
        ;*** 29-05-2008  Если режим широкого шрифта 16x4. *********
       ;**********************************************************
SET_POZITION_16x4:
        ;*****************;
        mov     zp_st,POZITION; Временное хранение данных переменной начального номера
                             ; знакоместа.
                            ; Переменная zp_st для определения начальной строки вывода символа.
        mov     zp_ml,POZITION; Временное хранение данных переменной начального номера
                             ; знакоместа.
                            ; Переменная zp_ml для восстановления данных переменной
                           ; начального номера знакоместа после выхода из пп. SET_POZITION.

        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...7 -LCD левой матрицы;
                         ;                    8...15 (08H...0FH) LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой матрицы"
     ;= данными из переменной POZ_STR. ===============================================

        mov     POZITION,#08H; Установить позицию "8" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...7 -LCD левой матрицы;
                          ;                    8...15 (08H...0FH) LCD правой матрицы.
                         ;-----------------------------------------------------------
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - правой матрицы"
     ;= данными переменной POZ_STR. ==================================================
    ;================================================================================


         ;*************************************************************************
        ;- 2. Установка требуемого начального знакоместа 0...15 (00H...0FH).
       ;*************************************************************************
      ; К данному моменту, в переменной zp_st находятся данные начального адреса
     ; знакоместа: POZITION. **************************************************
    ; (zp_st:= POZITION)    **************************************************

        mov     A,zp_st   ; Переменная zp_st(в ней данные POZITION) определяет выбор:
                         ; 0...7 -LCD левой матрицы
                        ; 8...15 (08H...0FH) LCD правой матрицы.
                       ;-----------------------------------------------------------
        cjne    A,#08H,SET_POZITION_Anal_16x4
SET_POZITION_Anal_16x4:
        jc      SET_POZITION_Left_16x4 ; Если позиция 0...7 для LCD левой матрицы.

         ;************************************************************************
        ; Если позиция 8...15 (08H...0FH) для LCD правой матрицы.
SET_POZITION_Right_16x4:
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...7 -LCD левой матрицы
                         ;       8...15 (08H...0FH) -LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;=============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой матрицы" ==============
     ;=============================================================================


        mov     POZITION,#08H; Установить позицию "8" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...7 -LCD левой матрицы
                          ;      8...15 (08H...0FH) LCD правой матрицы.
                         ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
;;        add     A,#POPRAVKA_RIGHT_LCD; (EQU 02H)
        mov     B,A                 ; Параметр поправки при адресации столбца LCD правой матрицы.
         ;-------------------------;
        ; К данному моменту, в переменной zp_st находятся данные начального адреса
       ; знакоместа: POZITION. **************************************************
      ; (zp_st:= POZITION)    **************************************************

 ;------ 11.05.2007 !!!------------------------------
        clr     C       ; C:=0.
        mov     A,zp_st
        subb    A,#08H
        mov     zp_st,A ; zp_st:= zp_st-8.
        ; Коррекция данных начального адреса
       ; знакоместа (POZITION), для обеспечения
      ; корректного определения адреса столбца -
     ; - знакоместа LCD - правой матрицы,
    ; в соответствии с адресом переменной POZITION.
;------ 11.05.2007 !!!----------------------------

;;        mov     A,zp_st ;??? Нужна ли эта команда ???
        jz      Right_CUKL_End_16x4
        ;--------------------
SET_POZITION_Right_CUKL_16x4:
        mov     A,#8
        add     A,B
        mov     B,A
        ;----------
        djnz    zp_st,SET_POZITION_Right_CUKL_16x4

Right_CUKL_End_16x4:
        mov     A,B
;+++ 02-06-2008 ++++++++++;
        mov     SLC,A    ; Сохранить вычисленный адрес столбца в промежуточной
                        ; переменной для использования в пп. LcdDataWriteSt,
;+++ 02-06-2008 +++++++; в режиме широкого шрифта.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;==============================================================================
      ;= Команда "Установить требуемый адрес столбца (знакоместо) LCD - правой матрицы
     ;= данными в соответствии с адресом переменной POZITION.
    ;==============================================================================

       ;==============================================================================
;;        anl     POZ_STR,#06H    ; Переменная позиции строки в
;;                               ; режиме широкого шрифта должна
;;                              ; быть только ЧЁТНОЙ, и принимать
;;                             ; 4-ре исходных значения: 0, 2, 4, 6.
;;                            ;************************************
;;        anl     zp_ml,#0FH   ; Переменная позиции знака в режиме
;;                            ; широкого шрифта может принимать
;;                           ; значения только: 0...15.
;;
        ljmp    SET_POZITION_EXIT
         ;***********************************************************************



         ;***********************************************************************
        ; Если позиция 0...7 для LCD левой матрицы.
SET_POZITION_Left_16x4:
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...7 -LCD левой матрицы
                         ;      8...15 (08H...0FH) LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
        mov     B,A
         ;-----------------------;
        ; К данному моменту, в переменной zp_st находятся данные начального адреса
       ; знакоместа: POZITION. **************************************************
      ; (zp_st:= POZITION)    **************************************************
        mov     A,zp_st
        jz      Left_CUKL_End_16x4
        ;--------------------
SET_POZITION_Left_CUKL_16x4:
        mov     A,#8
        add     A,B
        mov     B,A
        ;----------
         djnz    zp_st,SET_POZITION_Left_CUKL_16x4

Left_CUKL_End_16x4:
        mov     A,B
;+++ 02-06-2008 ++++++++++;
        mov     SLC,A    ; Сохранить вычисленный адрес столбца в промежуточной
                        ; переменной для использования в пп. LcdDataWriteSt,
;+++ 02-06-2008 +++++++; в режиме широкого шрифта.
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;==============================================================================
      ;= Команда "Установить требуемый адрес столбца (знакоместо) LCD - левой матрицы
     ;= данными в соответствии с адресом переменной POZITION.
    ;==============================================================================


        mov     POZITION,#08H; Установить позицию "8" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...7 -LCD левой матрицы
                          ;       8...15 (08H...0FH) LCD правой матрицы.
                         ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                    ; Параметр поправки при адресации столбца LCD правой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (16 знаков х 4 строки).
       ;=============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - правой матрицы" =============
     ;=============================================================================

       ;==============================================================================
;;        anl     POZ_STR,#06H    ; Переменная позиции строки в
;;                               ; режиме широкого шрифта должна
;;                              ; быть только ЧЁТНОЙ, и принимать
;;                             ; 4-ре исходных значения: 0, 2, 4, 6.
;;                            ;************************************
;;        anl     zp_ml,#0FH   ; Переменная позиции знака в режиме
;;                            ; широкого шрифта может принимать
;;                           ; значения только: 0...15.

        ljmp    SET_POZITION_EXIT
        ;=======================================================================



        ;************* Если режим обычного шрифта. **********
SET_POZITION_000:
         ;*************************************************
        ;- 1. Установка требуемой строки знака 0...7 (1-8).
       ;**************************************************
        mov     zp_st,POZITION; Временное хранение данных переменной начального номера
                             ; знакоместа.
                            ; Переменная zp_st для определения начальной строки вывода символа.
        mov     zp_ml,POZITION; Временное хранение данных переменной начального номера
                             ; знакоместа.
                            ; Переменная zp_ml для восстановления данных переменной
                           ; начального номера знакоместа после выхода из пп. SET_POZITION.

        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы;
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы;
                        ;      11...20 (0BH...14H) LCD правой матрицы.
                       ;-----------------------------------------------------------
        mov     A,#0B8H
        mov     B,POZ_STR
        anl     B,#07H
        add     A,B  ; A:= A+B(POZ_STR =0...7)
        ;-----------------------------------;
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - левой матрицы"
     ;= данными из переменной POZ_STR. ===============================================

        mov     POZITION,#0BH; Установить позицию "10" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...9 -LCD левой матрицы;
                          ;      10...4-ре столбца левой+2 столбца LCD правой матрицы;
                         ;      11...20 (0BH...14H) LCD правой матрицы.
                        ;-----------------------------------------------------------
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;================================================================================
      ;= Команда "Установить требуемую страницу (строку знака) ОЗУ LCD - правой матрицы"
     ;= данными переменной POZ_STR. ==================================================
    ;================================================================================


         ;*************************************************************************
        ;- 2. Установка требуемого начального знакоместа 0...20 (00H...14H).
       ;*************************************************************************
      ; К данному моменту, в переменной zp_st находятся данные начального адреса
     ; знакоместа: POZITION. **************************************************
    ; (zp_st:= POZITION)    **************************************************

        mov     A,zp_st   ; Переменная zp_st(в ней данные POZITION) определяет выбор:
                         ; 0...9 -LCD левой матрицы
                        ; 10...19 (0AH...13H) LCD правой матрицы.
                       ;------------------------------------------------------------------------------
        cjne    A,#0BH,SET_POZITION_Anal
SET_POZITION_Anal:
        jc      SET_POZITION_Left ; Если позиция 0...9 или 10 для LCD левой матрицы.

         ;************************************************************************
        ; Если позиция 11...20 (0BH...14H) для LCD правой матрицы.
SET_POZITION_Right:
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы;
                        ;      11...20 (0BH...14H) LCD правой матрицы.
                       ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;=============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - левой матрицы" ==============
     ;=============================================================================


        mov     POZITION,#0BH; Установить позицию "11" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...9 -LCD левой матрицы
                          ;      10...4-ре столбца левой+2 столбца LCD правой матрицы;
                         ;      11...20 (0BH...14H) LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_RIGHT_LCD; (EQU 02H)
        mov     B,A                 ; Параметр поправки при адресации столбца LCD правой матрицы.
         ;-------------------------;
        ; К данному моменту, в переменной zp_st находятся данные начального адреса
       ; знакоместа: POZITION. **************************************************
      ; (zp_st:= POZITION)    **************************************************

 ;------ 11.05.2007 !!!------------------------------
        clr     C       ; C:=0.
        mov     A,zp_st
        subb    A,#0BH
        mov     zp_st,A ; zp_st:= zp_st-10.
        ; Коррекция данных начального адреса
       ; знакоместа (POZITION), для обеспечения
      ; корректного определения адреса столбца -
     ; - знакоместа LCD - правой матрицы,
    ; в соответствии с адресом переменной POZITION.
;------ 11.05.2007 !!!----------------------------

;;        mov     A,zp_st ;??? Нужна ли эта команда ???
        jz      Right_CUKL_End
        ;--------------------
SET_POZITION_Right_CUKL:
        mov     A,#6
        add     A,B
        mov     B,A
        ;----------
        djnz    zp_st,SET_POZITION_Right_CUKL

Right_CUKL_End:
        mov     A,B
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;==============================================================================
      ;= Команда "Установить требуемый адрес столбца (знакоместо) LCD - правой матрицы
     ;= данными в соответствии с адресом переменной POZITION.
    ;==============================================================================

        ljmp    SET_POZITION_EXIT
         ;***********************************************************************



         ;***********************************************************************
        ; Если позиция 0...9 или 10 для LCD левой матрицы.
SET_POZITION_Left:
        mov     POZITION,#0 ; Установить позицию "0" номера знака в строке -
                           ; общая отслеживающая переменная обоих контроллеров LCD.
                          ; (Определяет выбор: 0...9 -LCD левой матрицы
                         ;      10...4-ре столбца левой+2 столбца LCD правой матрицы;
                        ;      11...20 (0BH...14H) LCD правой матрицы.
                       ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                   ; Параметр поправки при адресации столбца LCD левой матрицы.
        mov     B,A
         ;-----------------------;
        ; К данному моменту, в переменной zp_st находятся данные начального адреса
       ; знакоместа: POZITION. **************************************************
      ; (zp_st:= POZITION)    **************************************************
        mov     A,zp_st
        jz      Left_CUKL_End
        ;--------------------
SET_POZITION_Left_CUKL:
        mov     A,#6
        add     A,B
        mov     B,A
        ;----------
         djnz    zp_st,SET_POZITION_Left_CUKL

Left_CUKL_End:
        mov     A,B
        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (20 знаков х 8 строк).
       ;==============================================================================
      ;= Команда "Установить требуемый адрес столбца (знакоместо) LCD - левой матрицы
     ;= данными в соответствии с адресом переменной POZITION.
    ;==============================================================================


        mov     POZITION,#0BH; Установить позицию "11" номера знака в строке -
                            ; общая отслеживающая переменная обоих контроллеров LCD.
                           ; (Определяет выбор: 0...9 -LCD левой матрицы
                          ;      10...4-ре столбца левой+2 столбца LCD правой матрицы;
                         ;      11...20 (0BH...14H) LCD правой матрицы.
                        ;-----------------------------------------------------------
        mov     A,#40H
        add     A,#POPRAVKA_LEFT_LCD ; (EQU 00H)
                                    ; Параметр поправки при адресации столбца LCD правой матрицы.
     ;!!! Здесь ИМЕННО такой параметр поправки: POPRAVKA_LEFT_LCD (EQU 00H), т.к. если
    ;!!! имеется начальная позиция 0...9 или 10 для LCD левой матрицы, то при выводе
   ;!!! 10-го знака - последние его два столбца (из 6-ти) должны выводиться, в пп. LcdWriteSt
  ;!!! в начальные два столбца LCD правой матрицы.

        lcall   LcdComWriteSt
        ; Запись байта в регистр команд графического LCD (21 знак х 8 строк).
       ;=============================================================================
      ;= Команда "Установить адрес столбца 0 ОЗУ LCD - правой матрицы" =============
     ;=============================================================================

SET_POZITION_EXIT:
        mov     POZITION,zp_ml; Восстановление данных переменной начального номера
                             ; знакоместа.
        ret
   ;*******************************************************************************





         ;*****************************************************************
        ;*** Обработка параметров позиции строки и количества символов ***
       ;*** в случае режима широкого шрифта 16 символов х 4 строки.   ***
      ;*****************************************************************
LcdStrWriteSt_serialBufer_Sm_An:
         ;!! *****************************************************************
        ;!! 09-06-2008. Анализ битового признака режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *************************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 16 символов х 4 строки
                                    ; формат знака 6х14 пикселей.
     ;***********************************************************************
         ;******************************************************************
        jnb     Bit_Mode_16x4,LcdStrWriteSt_serialBufer_Sm_An_Exit
       ;*** Если режим обычного шрифта 21 символ х 8 строк. **************


         ;****************************************************************
        ;** Если режим широкого шрифта 16 символов х 4 строки. **********
       ;****************************************************************

        jb      Bit_Proced_Out_Simv,LcdStrWriteSt_serialBufer_Sm_An_2
      ;!! ******************************************************************
     ;!! Анализ командного битового признака режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************

         ;****************************************************************
        ;** Обнаружен признак вывода одиночного символа в режиме широкого
       ;** шрифта 16х4. KOL_SIMV:=1 ************************************
       mov      KOL_SIMV,#1
     ;****************************************************************

LcdStrWriteSt_serialBufer_Sm_An_2:
        ;*****************************************************************
       ;** 1. Обработка параметра позиции строки. ***********************
      ;*****************************************************************
        anl     POZ_STR,#06H    ; Переменная позиции строки в
                               ; режиме широкого шрифта должна
                              ; быть только ЧЁТНОЙ, и принимать
                             ; 4-ре исходных значения: 0, 2, 4, 6.

                            ;****************************************
;;         ;************************************************************
;;        ;** 2. Обработка параметра позиции знака в строке, **********
;;       ;************************************************************
;;LcdStrWriteSt_serialBufer_Sm_An_Poz:
;;         ;** 2.1. Первичная обработка параметра позиции знака. **
;;        ;*******************************************************
;;        mov     A,POZITION
;;        cjne    A,#16,LcdStrWriteSt_serialBufer_Sm_An_Poz_2
;;LcdStrWriteSt_serialBufer_Sm_An_Poz_2:
;;        ;********************;
;;        jc      LcdStrWriteSt_serialBufer_Sm_An_Poz_3
;;        ; Если POZITION < 16 (0...15).
;;
;;        ; Если POZITION >= 16.  (16...20)*;
;;        anl     POZITION,#0FH  ; ********;
;;        ;*********************;*********;


       ;***2.2. "Привязка" параметра позиции знака к параметру ***
      ;*******  количества символов в строке. *******************
LcdStrWriteSt_serialBufer_Sm_An_Poz_3:
        mov     A,POZITION
        jnz     LcdStrWriteSt_serialBufer_Sm_An_Poz_3A
          ; Если предположительно числовой параметр: POZITION >0.
         ; Уменьшается параметр POZITION (при необходимости).
        ;****************************************************;


         ;***************************************************;
        ; Если предположительно текстовая строка: POZITION =0.
       ; "Обрезается" количество символов справа.
      ;****************************************************;
        add     A,KOL_SIMV
        cjne    A,#17,LcdStrWriteSt_serialBufer_Sm_An_Poz_4
LcdStrWriteSt_serialBufer_Sm_An_Poz_4:
        ;*************************************************;
        jc      LcdStrWriteSt_serialBufer_Sm_An_Exit
        ; Если POZITION+KOL_SIMV < 17 (1...16).

        ; Если POZITION+KOL_SIMV >= 17.(17...21)*;
        dec     KOL_SIMV ; KOL_SIMV:= KOL_SIMV - 1.
        ljmp    LcdStrWriteSt_serialBufer_Sm_An_Poz_3
        ;*********************************************;

LcdStrWriteSt_serialBufer_Sm_An_Exit:
        ret
   ;*******************************************************************************

         ;*******************************************************
        ; Если предположительно числовой параметр: POZITION >0.
       ; Уменьшается параметр POZITION (при необходимости).
      ;****************************************************;
LcdStrWriteSt_serialBufer_Sm_An_Poz_3A:
        mov     A,POZITION
        ;************************************************;
LcdStrWriteSt_serialBufer_Sm_An_Poz_3B:
        add     A,KOL_SIMV
        cjne    A,#17,LcdStrWriteSt_serialBufer_Sm_An_Poz_4A
LcdStrWriteSt_serialBufer_Sm_An_Poz_4A:
        ;*********************************************;
        jc      LcdStrWriteSt_serialBufer_Sm_An_Exit
        ; Если POZITION+KOL_SIMV < 17 (1...16).

        ; Если POZITION+KOL_SIMV >= 17.(17...21)*;
        dec     POZITION ; POZITION:= POZITION - 1.
        ;***************;
        mov     A,POZITION
        cjne    A,#0FFH,LcdStrWriteSt_serialBufer_Sm_An_Poz_3A
        ;***************************************************;
        mov     POZITION,#0
        ljmp    LcdStrWriteSt_serialBufer_Sm_An_Poz_3
        ;*********************************************;






;*** 04.02.08 ******** 000. Запись строк в индикатор из serialBufer (EQU 5BH) *******
;                        с заданного смещения буфера. Входные параметры:
;-------------------------------------------------------------------------------
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...168 (01H...A8H).
;       B:= заданное смещение буфера serialBufer.
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
;;LcdStrWriteSt_serialBufer_Smesh:
;;        setb    Bit_Proced_Out_Simv
;;      ;!! ******************************************************************
;;     ;!! Установить командный битовый признак режима вывода множества символов
;;    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
;;   ;!! позиции строки и количества символов, в случае режима широкого шрифта
;;  ;!! LcdStrWriteSt_serialBufer_Sm_An.
;;                                 ; "0" - вывод одиночного символа, при этом
;;                                ; переменная KOL_SIMV:=1, в начале данной пп.
;;                               ; "1" - вывод множества символов, при этом
;;                              ; переменная KOL_SIMV в начале данной пп.
;;                             ; не модифицируется.
;;;************************************************************************
;;        push    B
;;        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
;;       ;*** по данным переменных:
;;      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;;     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
;;    ;*********************************************************************************
;;        lcall   SET_POZITION
;;        pop     B
;;        ;--------
;;        mov     A,#serialBufer
;;        add     A,B
;;        mov     R0,A
;;        ljmp    LcdStrWriteSt_Buff0_CUKL
        ;****************************************************************************








;*** 15.06.07 ******** 1. Запись строк в индикатор из буфера 0 *********************
;                        с заданного смещения буфера. Входные параметры:
;-------------------------------------------------------------------------------
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...168 (01H...A8H).
;       B:= заданное смещение буфера 0 (0...167)
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
LcdStrWriteSt_Buff0_Smesh:
        setb    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Установить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************
        push    B
        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
        lcall   SET_POZITION
        pop     B
        ;--------
        mov     A,#BufferIND_0
        add     A,B
        mov     R0,A
        ljmp    LcdStrWriteSt_Buff0_CUKL
        ;****************************************************************************


;*** 03.05.07 ******** 1. Запись строк в индикатор из буфера 0  *********************
;********************    (с начального адреса буфера).         *********************
; Входные параметры:
;-------------------------------------------------------------------------------
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...168 (01H...A8H).
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
LcdStrWriteSt_Buff0:
        setb    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Установить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************

        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
        lcall   SET_POZITION

        mov     R0,#BufferIND_0


LcdStrWriteSt_Buff0_CUKL:
        mov     A,R0
        push    ACC  ; Сохранить в стеке адресный указатель BufferIND_0.
        ;-----------;
        mov     A,@R0
        ;***********************
        ;----------------------
        lcall   LcdDataWriteSt
                ;=== 10.04.07 =============================================================
               ; Запись знака в графический LCD (21 знак х 8 строк).
              ;       Входной параметр: <A>: =записываемое значение в коде ASCII.
             ; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков,
            ; >00H -есть выделение.
           ; Используемые регистры: ACC, R0, R7, переменные: STB0...STB5.
          ; Инкрементирует переменную позиции знака POZITION (и адреса столбцов LCD),
         ; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирует
        ; переменную позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
       ; При переполнении (POZ_STR > 7) - POZ_STR:=0.
        ;========================================================================
        pop     ACC   ; Восстановить из стека адресный указатель BufferIND_0.
        mov     R0,A ;
        ;-----------;

        inc     R0
        djnz    KOL_SIMV,LcdStrWriteSt_Buff0_CUKL

        clr    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Сбросить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************
        ret
   ;*******************************************************************************












;*** 15.06.07 ******** 2. Запись строк в индикатор из буфера 1 *********************
;                        с заданного смещения буфера. Входные параметры:
;-------------------------------------------------------------------------------
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...168 (01H...A8H).
;       B:= заданное смещение буфера 1 (0...167)
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
LcdStrWriteSt_Buff1_Smesh:
        setb    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Установить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************
        push    B
        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
        lcall   SET_POZITION
        pop     B
        ;------------
        mov     DPTR,#BufferIND_1
        mov     A,DPL
        add     A,B
        mov     DPL,A
        ljmp    LcdStrWriteSt_Buff1_CUKL
        ;****************************************************************************



;*** 03.05.07 ******** 2. Запись строк в индикатор из буфера 1. *********************
;********************    (с начального адреса буфера).         *********************
; Входные параметры:
;-------------------------------------------------------------------------------
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...168 (01H...A8H).
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
LcdStrWriteSt_Buff1:
        setb    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Установить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************

        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
        lcall   SET_POZITION

        mov     DPTR,#BufferIND_1


LcdStrWriteSt_Buff1_CUKL:
        movx    A,@DPTR
        ;---------------------
        lcall   LcdDataWriteSt
                ;=== 10.04.07 =============================================================
               ; Запись знака в графический LCD (21 знак х 8 строк).
              ;       Входной параметр: <A>: =записываемое значение в коде ASCII.
             ; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков,
            ; >00H -есть выделение.
           ; Используемые регистры: ACC, R0, R7, переменные: STB0...STB5.
          ; Инкрементирует переменную позиции знака POZITION (и адреса столбцов LCD),
         ; и при переполнении: (POZITION > 19) - POZITION:=0 и, далее, инкрементирует
        ; переменную позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
       ; При переполнении (POZ_STR > 7) - POZ_STR:=0.
      ;========================================================================

        inc     DPTR
        djnz    KOL_SIMV,LcdStrWriteSt_Buff1_CUKL

        clr    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Сбросить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************
        ret
   ;*******************************************************************************





;*** 03.05.07 ******** 3. Запись в индикатор таблицы данных в ASCII кодах из ****
;********************     памяти программ управляющего микроконтроллера. *******
; Входные параметры:
;-------------------------------------------------------------------------------
; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков, >00H -есть выделение.
; POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
;  POZ_STR:= начальный адрес строки 0...7 (00H...07H);
; KOL_SIMV:= количество выводимых символов 1...168 (01H...A8H).
;     DPTR:= начальный адрес таблицы данных ASCII кодов в памяти программ.
;----------------------------------------------------------------------------
; Подпрограмма использует вложенную пп. LcdDataWriteSt, что обеспечивает
; инкрементирование переменной позиции знака POZITION (и адреса столбцов LCD),
; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирование
; переменной позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
; При переполнении (POZ_STR > 7) - POZ_STR:=0.
;========================================================================
;======================================================================
;====================================================================
LcdStrWriteSt_Tabl:
        setb    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Установить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************

        ;*** Установка адреса столбца и строки (страницы ОЗУ) графического LCD *********
       ;*** по данным переменных:
      ;*** POZITION:= начальный адрес знакоместа 0...20 (00H...14H);
     ;*** POZ_STR:= начальный адрес строки 0...7 (00H...07H);
    ;*********************************************************************************
        lcall   SET_POZITION


LcdStrWriteSt_Tabl_CUKL:
        clr     A
        movc    A,@A+DPTR
        
		CALL ANCI_TO_OEM
		
		
        
		lcall   LcdDataWriteSt
                ;=== 10.04.07 =============================================================
               ; Запись знака в графический LCD (21 знак х 8 строк).
              ;       Входной параметр: <A>: =записываемое значение в коде ASCII.
             ; PR_VIDELEN:= 00H нет выделения (негативного отобр.)выводимых знаков,
            ; >00H -есть выделение.
           ; Используемые регистры: ACC, R0, R7, переменные: STB0...STB5.
          ; Инкрементирует переменную позиции знака POZITION (и адреса столбцов LCD),
         ; и при переполнении: (POZITION > 20) - POZITION:=0 и, далее, инкрементирует
        ; переменную позиции строки для знака POZ_STR (и страницы ОЗУ LCD).
       ; При переполнении (POZ_STR > 7) - POZ_STR:=0.
      ;========================================================================

        inc     DPTR
        djnz    KOL_SIMV,LcdStrWriteSt_Tabl_CUKL

        clr    Bit_Proced_Out_Simv
      ;!! ******************************************************************
     ;!! Сбросить командный битовый признак режима вывода множества символов
    ;!! на дисплей кассира: используется для подпрограммы обработки параметров
   ;!! позиции строки и количества символов, в случае режима широкого шрифта
  ;!! LcdStrWriteSt_serialBufer_Sm_An.
                                 ; "0" - вывод одиночного символа, при этом
                                ; переменная KOL_SIMV:=1, в начале данной пп.
                               ; "1" - вывод множества символов, при этом
                              ; переменная KOL_SIMV в начале данной пп.
                             ; не модифицируется.
;************************************************************************
        ret
   ;*******************************************************************************



            ;*********************************************************************
           ; Обработка данных столбца графического индикатора - преобразование
          ; в двухбайтовый формат, для вывода их на индикатор, в режиме широкого
         ; шрифта 12х4, в страницы ОЗУ LCD: n и n+1.
        ; Исходные данные столбца в <A>.
       ;-------------------------------------------------
      ; Возврат: в <DPTR> преобразованные в двухбайтовый
     ; формат данные столбца столбца графического индикатора:
    ; DPH - данные столбца графического индикатора для
   ; страницы ОЗУ LCD - n+1.
  ; DPL - данные столбца графического индикатора для
 ; страницы ОЗУ LCD - n.
;**************************************************************************
Obrabot_12x4:
        ;**********************;
        push    ACC
        ;----------
        mov     A,PR_VIDELEN  ; Анализ признака выделения выводимых знаков
        cjne    A,#1,Obrabot_12x4_Cont_Pozitiv
        ; Если не нужен режим выделения.
        ;+++++++++++++++++++;

        ; Если НУЖЕН режим выделения.
Obrabot_12x4_Cont_Negativ:
        ;++++++++++;
        pop     ACC
        ;++++++++;
        mov     DPH,#0FFH
        mov     DPL,A
        ;+++++++++++
        mov     A,#7
        lcall   Sdwig_Obrabot_16x4_1; Сдвиг данных <DPTR> на 7 разрядов влево.
        ;--------------------------; с заполнением "1".
        ljmp    Obrabot_12x4_Continew
        ;********************************


        ; Если НЕ НУЖЕН режим выделения.
Obrabot_12x4_Cont_Pozitiv:
        ;++++++++++;
        pop     ACC
        ;++++++++;
        mov     DPH,#0
        mov     DPL,A
        ;+++++++++++
        mov     A,#7
        lcall   Sdwig_Obrabot_16x4_0; Сдвиг данных <DPTR> на 7 разрядов влево.
        ;--------------------------; с заполнением "0".
Obrabot_12x4_Continew:
         ;******************************************************************
        ;** Битовые пересылки данных столбца графического индикатора для **
       ;** страницы ОЗУ LCD - n (n+1).                    ****************
      ;** (Данные к данному моменту находятся в <DPTR>). ****************
        mov     B,DPH
        mov     A,DPL
       ;---------------
        mov     C,ACC.7
        mov     ACC.0,C ; ACC.0:=ACC.7
        mov     ACC.1,C ; ACC.1:=ACC.7
       ;---------------
        mov     C,B.0
        mov     ACC.2,C ; ACC.2:=B.0
        mov     ACC.3,C ; ACC.3:=B.0

               ;--------------
        mov     C,B.1
        mov     ACC.4,C ; ACC.4:=B.1
        mov     ACC.5,C ; ACC.5:=B.1
        ;--------------
        mov     C,B.2
        mov     ACC.6,C ; ACC.6:=B.2
        mov     ACC.7,C ; ACC.7:=B.2
        ;--------------
        mov     C,B.3
        mov     B.0,C   ; B.0: =B.3
        mov     B.1,C   ; B.1: =B.3
        ;--------------
        mov     C,B.4
        mov     B.2,C   ; B.2: =B.4
        mov     B.3,C   ; B.3: =B.4
        ;--------------
        mov     C,B.5
        mov     B.4,C   ; B.4: =B.5
       ;---------------;
        mov     C,B.6 ; B.7: =B.6 !!! 19-05-2010 !!!
        mov     B.7,C;
      ;---------------;
        mov     DPH,B;
        mov     DPL,A;
        ;-----------;
        ret
   ;*******************************************************************************




     ;*******************************************************************************
    ;********* Сдвиг влево пары регистров в <DPTR> на заданное количество бит. *****
   ;********* Вспомогательная пп., входит в пп. Obrabot_12x4.    ******************
  ;********* с заполнением "1".                                 ******************
 ;********* Входной параметр: количество сдвигаемых бит в <A>. ******************
Sdwig_Obrabot_16x4_1:
        ;-----------------;
        push    ACC      ; Сохранить в стеке значение количества сдвигаемых бит.
        ;---------------;
        SETB    C      ; C:=1.
        ;-------------;
        MOV     A,DPL
        RLC     A
        MOV     DPL,A
        ;-----------
        MOV     A,DPH
        RLC     A
        MOV     DPH,A
        ;--------------;
                      ;
        pop     ACC  ; Извлечь из стека значение кол-ва сдвигаемых бит.
        ;-----------;
        DJNZ    ACC,Sdwig_Obrabot_16x4_1
        ;*********************************
        ret
;**********************************************************************************



     ;*******************************************************************************
    ;********* Сдвиг влево пары регистров в <DPTR> на заданное количество бит. *****
   ;********* Вспомогательная пп., входит в пп. Obrabot_12x4.    ******************
  ;********* с заполнением "0".                                 ******************
 ;********* Входной параметр: количество сдвигаемых бит в <A>. ******************
Sdwig_Obrabot_16x4_0:
        ;-----------------;
        push    ACC      ; Сохранить в стеке значение количества сдвигаемых бит.
        ;---------------;
        CLR     C      ; C:=0.
        ;-------------;
        MOV     A,DPL
        RLC     A
        MOV     DPL,A
        ;-----------
        MOV     A,DPH
        RLC     A
        MOV     DPH,A
        ;--------------;
                      ;
        pop     ACC  ; Извлечь из стека значение кол-ва сдвигаемых бит.
        ;-----------;
        DJNZ    ACC,Sdwig_Obrabot_16x4_0
        ;*********************************
        ret
;**********************************************************************************




;*******************************************************************************

;=== 28.04.07 ================================================================
; Кодировщик символьной таблицы графического индикатора 128х64 точки
; Формат знака: 5х7 пикселей (плюс 6-ой "пустой" столбец и 8-я "пустая" строка).
; ** Входной параметр: <A>: = ASCII код знака.
; ***************************************************************************
; Возврат: STB0...STB5:=Шесть байтов кодов столбцов знака графич. индикатора.
;===========================================================================
LcdTrans:
;** 28.04.2007 *****************
        push    ACC
        ;----------
        push    DPL
        push    DPH
        ;----------
        mov     DPTR,#SmbTable
          ; Определение смещения в строках таблицы для
         ; загрузки кода первого столбца требуемого знака.
        ; -----------------------------------------------
        jz      LcdTrans_A
        mov     R2,A
        ;-------------
LcdTrans_Cukl_1:
        clr     C       ; C:=0
        mov     A,DPL
        addc    A,#6
        mov     DPL,A
        ;------------
        mov     A,DPH
        addc    A,#0
        mov     DPH,A
        ;--------------------------;
        djnz    R2,LcdTrans_Cukl_1;
        ;------------------------;
LcdTrans_A:                     ;
        mov     R2,#6     ; Установка счётчика количества столбцов.
        ;----------------;
        mov     R0,#STB0; Переменные для хранения кодов
                       ; столбцов знака графич. индикатора
                      ; физически в оперативной памяти
                     ; распределяются подряд:
                    ; STB0...STB5. *********************
LcdTrans_Cukl_2:
        ;*******************
        clr     C
        ;-----------------;
        mov     A,#6     ; 6 - <R2>
        subb    A,R2    ; Определение смещения в таблице для
                       ; считывания кода столбца требуемого знака.
        ;******************;
        movc    A,@A+DPTR ; Считывание кода столбца.
		
        ;++++++++++++++++;


        ;***************************************
        push    ACC
        ;+++++++++
        mov     A,PR_VIDELEN  ; Анализ признака выделения выводимых знаков
        cjne    A,#1,VIDEL_EX; Если не нужен режим выделения.
        ;+++++++++++++++++++;
       ; Если нужен режим выделения.
        pop     ACC
        ;+++++++++
        cpl     A
        ljmp    VIDEL_EX_A
        ;+++++++++++++++;
        ;********************************
VIDEL_EX:
        ;+++++++++
        pop     ACC
VIDEL_EX_A:
        ;*****************************


        mov     @R0,A    ; Занесение считанного кода
                        ; в переменные STB0...STB5.
        inc     R0
        ;-------------;
        djnz    R2,LcdTrans_Cukl_2
        ;-----------------------;
        pop     DPH
        pop     DPL
        ;----------
        pop     ACC
        ;----------
        ret


 ; ** Таблица кодов знакогенератора ****************
; Коды столбцов знака графич. индикатора ; ASC код:
SmbTable: ;     ----------------------- ;--------
        DB      01H,00H,00H,00H,00H,00H ; 00H
        DB      00H,00H,00H,00H,00H,00H ; 01H
        DB      00H,00H,00H,00H,00H,00H ; 02H
        DB      00H,00H,00H,00H,00H,00H ; 03H
        DB      00H,00H,00H,00H,00H,00H ; 04H
        DB      00H,00H,00H,00H,00H,00H ; 05H
        DB      10H,1EH,3FH,1EH,10H,00H ; 06H
        DB      00H,00H,00H,00H,00H,00H ; 07H
        ;------------------------------------
        DB      00H,00H,00H,00H,00H,00H ; 08H
        DB      00H,00H,00H,00H,00H,00H ; 09H
        DB      0EH,45H,0EEH,40H,78H,00H; 0AH
        DB      00H,00H,00H,00H,00H,00H ; 0BH
        DB      00H,00H,00H,00H,00H,00H ; 0CH
        DB      08H,1CH,2AH,08H,0FH,00H ; 0DH
        DB      00H,00H,00H,00H,00H,00H ; 0EH
        DB      00H,00H,00H,00H,00H,00H ; 0FH
        ;------------------------------------
        DB      00H,00H,00H,00H,00H,00H ; 10H
        DB      00H,00H,00H,00H,00H,00H ; 11H
        DB      00H,00H,00H,00H,00H,00H ; 12H
        DB      00H,5CH,00H,5CH,00H,00H ; 13H
        DB      06H,09H,7FH,09H,7FH,00H ; 14H
        DB      40H,9AH,0A5H,59H,02H,00H; 15H
        DB      00H,00H,00H,00H,00H,00H ; 16H
        DB      00H,00H,00H,00H,00H,00H ; 17H
        ;------------------------------------
        DB      04H,02H,7FH,02H,04H,00H ; 18H
        DB      10H,20H,7FH,20H,10H,00H ; 19H
        DB      08H,3EH,1CH,08H,7FH,00H ; 1AH
        DB      7FH,08H,1CH,3EH,08H,00H ; 1BH
        DB      7EH,08H,10H,20H,7EH,00H ; 1CH
        DB      18H,18H,0FFH,7EH,3CH,18H; 1DH
        DB      2EH,2AH,2EH,00H,00H,00H ; 1EH
        DB      18H,3CH,7EH,0FFH,18H,18H; 1FH
        ;------------------------------------
        DB      00H,00H,00H,00H,00H,00H ; 20H
        DB      00H,00H,4FH,00H,00H,00H ; 21H     !
        DB      00H,07H,00H,07H,00H,00H ; 22H     "
        DB      14H,7FH,14H,7FH,14H,00H ; 23H     #
        DB      24H,2AH,7FH,2AH,12H,00H ; 24H     $
        DB      23H,13H,08H,64H,62H,00H ; 25H     %
        DB      36H,49H,55H,22H,50H,00H ; 26H     &
        DB      00H,05H,03H,00H,00H,00H ; 27H     '
        ;------------------------------------
        DB      00H,1CH,22H,41H,00H,00H ; 28H     (
        DB      00H,41H,22H,1CH,00H,00H ; 29H     )
        DB      14H,08H,3EH,08H,14H,00H ; 2AH     *
        DB      08H,08H,3EH,08H,08H,00H ; 2BH     +
        DB      00H,50H,30H,00H,00H,00H ; 2CH     ,
        DB      08H,08H,08H,08H,08H,00H ; 2DH     -
        DB      00H,60H,60H,00H,00H,00H ; 2EH     .
        DB      20H,10H,08H,04H,02H,00H ; 2FH     /
        ;------------------------------------
        DB      3EH,51H,49H,45H,3EH,00H ; 30H     0
        DB      00H,42H,7FH,40H,00H,00H ; 31H     1
        DB      42H,61H,51H,49H,46H,00H ; 32H     2
        DB      21H,41H,45H,4BH,31H,00H ; 33H     3
        DB      18H,14H,12H,7FH,10H,00H ; 34H     4
        DB      27H,45H,45H,45H,39H,00H ; 35H     5
        DB      3CH,4AH,49H,49H,30H,00H ; 36H     6
        DB      01H,71H,09H,05H,03H,00H ; 37H     7
        ;------------------------------------
        DB      36H,49H,49H,49H,36H,00H ; 38H     8
        DB      06H,49H,49H,29H,1EH,00H ; 39H     9
        DB      00H,36H,36H,00H,00H,00H ; 3AH     :
        DB      00H,56H,36H,00H,00H,00H ; 3BH     ;
        DB      08H,14H,22H,41H,00H,00H ; 3CH     <
        DB      14H,14H,14H,14H,14H,00H ; 3DH     =
        DB      00H,41H,22H,14H,08H,00H ; 3EH     >
        DB      02H,01H,51H,09H,06H,00H ; 3FH     ?
        ;------------------------------------
        DB      32H,49H,79H,41H,3EH,00H ; 40H     @
        DB      7EH,11H,11H,11H,7EH,00H ; 41H     A
        DB      7FH,49H,49H,49H,36H,00H ; 42H     B
        DB      3EH,41H,41H,41H,22H,00H ; 43H     C
        DB      7FH,41H,41H,22H,1CH,00H ; 44H     D
        DB      7FH,49H,49H,49H,41H,00H ; 45H     E
        DB      7FH,09H,09H,09H,01H,00H ; 46H     F
        DB      3EH,41H,49H,49H,7AH,00H ; 47H     G
        ;------------------------------------
        DB      7FH,08H,08H,08H,7FH,00H ; 48H     H
        DB      00H,41H,7FH,41H,00H,00H ; 49H     I
        DB      20H,40H,41H,3FH,01H,00H ; 4AH     J
        DB      7FH,08H,14H,22H,41H,00H ; 4BH     K
        DB      7FH,40H,40H,40H,40H,00H ; 4CH     L
        DB      7FH,02H,0CH,02H,7FH,00H ; 4DH     M
        DB      7FH,04H,08H,10H,7FH,00H ; 4EH     N
        DB      3EH,41H,41H,41H,3EH,00H ; 4FH     O
        ;------------------------------------
        DB      7FH,09H,09H,09H,06H,00H ; 50H     P
        DB      3EH,41H,51H,21H,5EH,00H ; 51H     Q
        DB      7FH,09H,19H,29H,46H,00H ; 52H     R
        DB      46H,49H,49H,49H,31H,00H ; 53H     S
        DB      01H,01H,7FH,01H,01H,00H ; 54H     T
        DB      3FH,40H,40H,40H,3FH,00H ; 55H     U
        DB      1FH,20H,40H,20H,1FH,00H ; 56H     V
        DB      3FH,40H,30H,40H,3FH,00H ; 57H     W
        ;------------------------------------
        DB      63H,14H,08H,14H,63H,00H ; 58H     X
        DB      07H,08H,70H,08H,07H,00H ; 59H     Y
        DB      61H,51H,49H,45H,43H,00H ; 5AH     Z
        DB      00H,7FH,41H,41H,00H,00H ; 5BH     [
        DB      01H,01H,01H,01H,01H,01H ; 5CH -Символ курсора в верхней части знака.
        DB      00H,41H,41H,7FH,00H,00H ; 5DH     ]
        DB      04H,02H,01H,02H,04H,00H ; 5EH     ^
        DB      40H,40H,40H,40H,40H,00H ; 5FH     _
        ;------------------------------------
        DB      00H,01H,02H,00H,00H,00H ; 60H    `
        DB      20H,54H,54H,54H,78H,00H ; 61H     a
        DB      7FH,48H,44H,44H,38H,00H ; 62H     b
        DB      38H,44H,44H,44H,20H,00H ; 63H     c
        DB      38H,44H,44H,48H,7FH,00H ; 64H     d
        DB      38H,54H,54H,54H,18H,00H ; 65H     e
        DB      08H,7EH,09H,01H,02H,00H ; 66H     f
        DB      08H,54H,54H,54H,3CH,00H ; 67H     g
        ;------------------------------------
        DB      7FH,08H,04H,04H,78H,00H ; 68H     h
        DB      00H,44H,7DH,40H,00H,00H ; 69H     i
        DB      20H,40H,44H,3DH,00H,00H ; 6AH     j
        DB      7FH,10H,28H,44H,00H,00H ; 6BH     k
        DB      00H,41H,7FH,40H,00H,00H ; 6CH     l
        DB      7CH,04H,18H,04H,78H,00H ; 6DH     m
        DB      7CH,08H,04H,04H,78H,00H ; 6EH     n
        DB      38H,44H,44H,44H,38H,00H ; 6FH     o
        ;------------------------------------
        DB      7CH,14H,14H,14H,08H,00H ; 70H     p
        DB      08H,14H,14H,14H,7CH,00H ; 71H     q
        DB      7CH,08H,04H,04H,08H,00H ; 72H     r
        DB      48H,54H,54H,54H,20H,00H ; 73H     s
        DB      04H,3FH,44H,40H,20H,00H ; 74H     t
        DB      3CH,40H,40H,20H,7CH,00H ; 75H     u
        DB      1CH,20H,40H,20H,1CH,00H ; 76H     v
        DB      3CH,40H,30H,40H,3CH,00H ; 77H     w
        ;------------------------------------
        DB      44H,28H,10H,28H,44H,00H ; 78H     x
        DB      0CH,50H,50H,50H,3CH,00H ; 79H     y
        DB      44H,64H,54H,4CH,44H,00H ; 7AH     z
        DB      7FH,49H,31H,0C0H,30H,0CH; 7BH ----\--Вывод символа "Б/К" на два знакоместа:
        DB      03H,7EH,10H,28H,44H,00H ; 7CH ----\  должна быть пара кодов подряд-7BH,7CH.
        DB      40H,40H,40H,40H,40H,40H ; 7DH -Символ курсора в нижней части знака.
        DB      02H,01H,02H,02H,01H,00H ; 7EH     ~
        DB      0FFH,0FFH,0FFH,0FFH,0FFH,00H ; 7FH
        ;------------------------------------		
        DB      7EH,11H,11H,11H,7EH,00H ; 80H     А	 ;--------------------
        DB      7FH,49H,49H,49H,33H,00H ; 81H     Б
        DB      7FH,49H,49H,49H,36H,00H ; 82H     В
        DB      7FH,01H,01H,01H,03H,00H ; 83H     Г
        DB      0E0H,51H,4FH,41H,0FFH,00H;84H     Д
        DB      7FH,49H,49H,49H,41H,00H ; 85H     Е
        DB      77H,08H,7FH,08H,77H,00H ; 86H     Ж
        DB      49H,49H,49H,49H,36H,00H ; 87H     З
        ;------------------------------------
        DB      7FH,10H,08H,04H,7FH,00H ; 88H     И
        DB      7CH,21H,12H,09H,7CH,00H ; 89H     Й
        DB      7FH,08H,14H,22H,41H,00H ; 8AH     К
        DB      20H,41H,3FH,01H,7FH,00H ; 8BH     Л
        DB      7FH,02H,0CH,02H,7FH,00H ; 8CH     М
        DB      7FH,08H,08H,08H,7FH,00H ; 8DH     Н
        DB      3EH,41H,41H,41H,3EH,00H ; 8EH     О
        DB      7FH,01H,01H,01H,7FH,00H ; 8FH     П
        ;------------------------------------
        DB      7FH,09H,09H,09H,06H,00H ; 90H     Р
        DB      3EH,41H,41H,41H,22H,00H ; 91H     С
        DB      01H,01H,7FH,01H,01H,00H ; 92H     Т
        DB      47H,28H,10H,08H,07H,00H ; 93H     У
        DB      1CH,22H,7FH,22H,1CH,00H ; 94H     Ф
        DB      63H,14H,08H,14H,63H,00H ; 95H     Х
        DB      7FH,40H,40H,40H,0FFH,00H; 96H     Ц
        DB      07H,08H,08H,08H,7FH,00H ; 97H     Ч
        ;------------------------------------
        DB      7FH,40H,7FH,40H,7FH,00H ; 98H     Ш
        DB      7FH,40H,7FH,40H,0FFH,00H; 99H     Щ
        DB      01H,7FH,48H,48H,30H,00H ; 9AH     Ъ
        DB      7FH,48H,30H,00H,7FH,00H ; 9BH     Ы	   Кодировка OEM
        DB      7FH,48H,48H,30H,00H,00H ; 9CH     Ь
        DB      22H,41H,49H,49H,3EH,00H ; 9DH     Э
        DB      7FH,08H,3EH,41H,3EH,00H ; 9EH     Ю
        DB      46H,29H,19H,09H,7FH,00H ; 9FH     Я
        ;------------------------------------
        DB      20H,54H,54H,54H,78H,00H ; A0H     а
        DB      3CH,4AH,4AH,49H,31H,00H ; A1H     б
        DB      7CH,54H,54H,28H,00H,00H ; A2H     в
        DB      7CH,04H,04H,04H,0CH,00H ; A3H     г
        DB      0E0H,54H,4CH,44H,0FCH,00H;A4H     д
        DB      38H,54H,54H,54H,18H,00H ; A5H     е
        DB      6CH,10H,7CH,10H,6CH,00H ; A6H     ж
        DB      44H,44H,54H,54H,28H,00H ; A7H     з
        ;------------------------------------
        DB      7CH,20H,10H,08H,7CH,00H ; A8H     и
        DB      78H,42H,24H,12H,78H,00H ; A9H     й
        DB      7CH,10H,28H,44H,00H,00H ; AAH     к
        DB      20H,44H,3CH,04H,7CH,00H ; ABH     л
        DB      7CH,08H,10H,08H,7CH,00H ; ACH     м
        DB      7CH,10H,10H,10H,7CH,00H ; ADH     н
        DB      38H,44H,44H,44H,38H,00H ; AEH     о
        DB      7CH,04H,04H,04H,7CH,00H ; AFH     п	 -------------------------
        ;------------------------------------
        DB      55H,00H,0AAH,00H,55H,00H; B0H
        DB      55H,0AAH,00H,55H,0AAH,00H;B1H
        DB      55H,2AH,55H,2AH,55H,2AH ; B2H
        DB      00H,00H,0FFH,00H,00H,00H; B3H
        DB      08H,08H,0FFH,00H,00H,00H; B4H
        DB      14H,14H,0FFH,00H,00H,00H; B5H
        DB      08H,08H,0FFH,00H,0FFH,00H;B6H
        DB      08H,08H,0F8H,08H,0F8H,00H;B7H
        ;------------------------------------
        DB      14H,14H,0FCH,00H,00H,00H; B8H
        DB      14H,14H,0F7H,00H,0FFH,00H;B9H
        DB      00H,00H,0FFH,00H,0FFH,00H;BAH
        DB      14H,14H,0F4H,04H,0FCH,00H;BBH
        DB      14H,14H,17H,10H,1FH,00H;  BCH
        DB      08H,08H,0FH,08H,0FH,00H;  BDH
        DB      14H,14H,1FH,00H,00H,00H;  BEH
        DB      08H,08H,0F8H,00H,00H,00H ;BFH
        ;------------------------------------	 
        DB      00H,00H,0FH,08H,08H,08H ; C0H
        DB      08H,08H,0FH,08H,08H,08H ; C1H
        DB      08H,08H,0F8H,08H,08H,08H; C2H
        DB      00H,00H,0FFH,08H,08H,08H; C3H
        DB      08H,08H,08H,08H,08H,08H ; C4H
        DB      08H,08H,0FFH,08H,08H,08H; C5H
        DB      00H,00H,0FFH,08H,08H,08H; C6H
        DB      00H,00H,0FFH,00H,0FFH,08H;C7H
        ;------------------------------------
        DB      00H,00H,1FH,10H,17H,14H  ;C8H
        DB      00H,00H,0FCH,04H,0F4H,14H;C9H
        DB      14H,14H,17H,10H,17H,14H ; CAH
        DB      14H,14H,0F4H,04H,0F4H,14H;CBH
        DB      00H,00H,0FFH,00H,0F7H,14H;CCH
        DB      14H,14H,14H,14H,14H,14H ; CDH
        DB      14H,14H,0F7H,00H,0F7H,14H;CEH
        DB      14H,14H,17H,14H,14H,14H ; CFH
        ;------------------------------------
        DB      08H,08H,0FH,08H,0FH,08H ; D0H
        DB      14H,14H,0F4H,14H,14H,14H; D1H
        DB      08H,08H,0F8H,08H,0F8H,08H;D2H
        DB      00H,00H,0FH,08H,0FH,08H ; D3H
        DB      00H,00H,1FH,14H,14H,14H ; D4H
        DB      00H,00H,0FCH,14H,14H,14H; D5H
        DB      00H,00H,0F8H,08H,0F8H,08H;D6H
        DB      08H,08H,0FFH,00H,0FFH,08H;D7H

        ;------------------------------------
        DB      14H,14H,0F7H,14H,14H,14H ;D8H
        DB      08H,08H,0FH,00H,00H,00H ; D9H
        DB      00H,00H,0F8H,08H,08H,08H ;DAH
        DB      00H,1CH,1CH,1CH,00H,00H ; DBH
        DB      00H,18H,18H,18H,18H,00H ; DCH
        DB      00H,00H,3CH,3CH,00H,00H ; DDH
        DB      00H,00H,3CH,3CH,00H,00H ; DEH
        DB      00H,06H,06H,06H,06H,00H ; DFH
        ;------------------------------------
        DB      7CH,14H,14H,14H,08H,00H ; E0H     р
        DB      38H,44H,44H,44H,20H,00H ; E1H     с
        DB      04H,04H,7CH,04H,04H,00H ; E2H     т
        DB      0CH,50H,50H,50H,3CH,00H ; E3H     у
        DB      30H,48H,0FEH,48H,30H,00H; E4H     ф
        DB      44H,28H,10H,28H,44H,00H ; E5H     х
        DB      7CH,40H,40H,40H,0FCH,00H; E6H     ц
        DB      0CH,10H,10H,10H,7CH,00H ; E7H     ч
        ;------------------------------------
        DB      7CH,40H,7CH,40H,7CH,00H ; E8H     ш
        DB      7CH,40H,7CH,40H,0FCH,00H; E9H     щ
        DB      04H,7CH,50H,50H,20H,00H ; EAH     ъ
        DB      7CH,50H,20H,00H,7CH,00H ; EBH     ы
        DB      7CH,50H,50H,20H,00H,00H ; ECH     ь
        DB      28H,44H,54H,54H,38H,00H ; EDH     э
        DB      7CH,10H,38H,44H,38H,00H ; EEH     ю
        DB      08H,54H,34H,14H,7CH,00H ; EFH     я
        ;------------------------------------
        DB      7CH,55H,54H,45H,00H,00H ; F0H     Ё
        DB      38H,55H,54H,55H,18H,00H ; F1H     ё
        DB      1FH,00H,1FH,11H,1FH,00H ; F2H                                          /
        DB      20H,20H,20H,10H,10H,08H ; F3H     F3H...F5H подряд - Н.О. контакт: __/  \__
        DB      08H,04H,04H,02H,02H,31H ; F4H                                         ___
        DB      21H,20H,20H,20H,00H,00H ; F5H     F6H...F8H подряд - Н.З. контакт: __|  \__
        DB      04H,04H,04H,08H,08H,10H ; F6H
        DB      10H,20H,20H,40H,40H,0FCH; F7H
        ;------------------------------------
        DB      84H,04H,04H,04H,00H,00H ; F8H
        DB      00H,00H,0E0H,20H,20H,20H; F9H
        DB      10H,10H,54H,10H,10H,00H ; FAH
        DB      44H,44H,5FH,44H,44H,00H ; FBH
        DB      7EH,08H,10H,7EH,15H,12H ; FCH     №
        DB      01H,01H,01H,01H,01H,01H ; FDH
        DB      00H,00H,00H,00H,00H,0FFH; FEH
        DB      40H,40H,40H,40H,40H,40H ; FFH
        ;***************************************************************
;**********************************************************************
        
		ANCI_TO_OEM:
		;================================
		;================================
		;Перекодировка символов кириллицы 
		; из ANCI 1251 в КОИ-8
		;================================
		;================================
		
		CLR C
		
		;*******************************
		;1-Е УСЛОВИЕ
		; IF A>0EFH
		; A=A-10H
		;*******************************
												   ;----------
		CJNE A,#0F0H,MET1                       ;A>0EFH ???
		MET1: 
		JC NEXT2 ;      IF A<0F0H (C=1) или <= 0EFH TO NEXT2 ;----------		
		;-------------------------------------------------------------
		; IF A>0EFH (C=0) или >= 0F0H.
		CLR C ;СБРОС "С" НА ВСЯКИЙ СЛУЧАЙ
		SUBB A, #010H ;A=A-010H
		SJMP EXIT ;ВЫХОД ИЗ ПРОЦЕДУРЫ
		
		
		;*********** IF A<0F0H (C=1) или <= 0EFH *****************
		NEXT2:
		;*******************************
		;2-Е УСЛОВИЕ
		; IF F0H>A>BFH
		; A=A+40H
		;*******************************
		
		CJNE A,#0C0H,MET2  						  ;----------
		MET2: JC NEXT3 ;IF A<0C0FH (C=1) или <= 0BFH TO NEXT3  ;A>0BFH ???
		;--------------------------------------------------------------
		; IF A>0BFH (C=0) или >= 0C0H.										  ;----------		
		;;;;; Этого не надо!!! CJNE A,#0F0H,MET3 ;			              ;----------
		;;;;; Этого не надо!!! MET3: JNC NEXT3 ;IF A>F0H (C=0) TO EXIT	  ;A<F0H ???
		CLR C ;СБРОС "С" НА ВСЯКИЙ СЛУЧАЙ         ;----------
		SUBB A, #040H ;A=A-040H
		SJMP EXIT ;ВЫХОД ИЗ ПРОЦЕДУРЫ
		
		;******************************
		NEXT3:
		;*******************************
		;3-Е УСЛОВИЕ (ПЕРЕКОД 'Ё')
		; IF A=A8H
		; A=F0H
		;*******************************
		
		CJNE A,#0A8H,NEXT4 ;A=0A8H ???, GOTO NEXT4, ЕСЛИ НЕ РАВНО
		MOV A,#0F0H
		SJMP EXIT ;ВЫХОД ИЗ ПРОЦЕДУРЫ
		
		;******************************
		NEXT4:
		;*******************************
		;4-Е УСЛОВИЕ (ПЕРЕКОД 'ё')
		; IF A=B8H
		; A=F1H
		;*******************************
		
		CJNE A,#0B8H,NEXT5 ;A=0B8H ???, GOTO NEXT5, ЕСЛИ НЕ РАВНО
		MOV A,#0F1H
		SJMP EXIT ;ВЫХОД ИЗ ПРОЦЕДУРЫ
		
		;******************************
		NEXT5:
		;*******************************
		;5-Е УСЛОВИЕ (ПЕРЕКОД '№')
		; IF A=B9H
		; A=FCH
		;*******************************
		
		CJNE A,#0B9H,EXIT ;A=0B9H ???, EXIT, ЕСЛИ НЕ РАВНО
		MOV A,#0FCH
				
		EXIT:
		RET

	
		
		
;*******************************************************************************
	   
;******************************************************************************
 ;///////////////////////////////////////////////////////////////
		; ПРЕОБР. ДВОИЧН. КОДА (DPTR) В ДВОИЧНО-ДЕСЯТИЧНЫЙ.
		; Результат - в DECST, DECML.
		;ВХОДОНОЙ ПАРАМЕТР В DPTR
		;; Результат - в переменных (ДЛЯ DEC20):
				; ML_RAZR, SR_RAZR- 4 младших дв.-дес. разряда;
				; ST_RAZR         - 2 старших дв.-дес. разряда.
		 ; МАКСИМАЛЬНОЕ ЧИСЛО ДЛЯ DEC20 = ПРИМЕРНО 1000000
 ;//////////////////////////////////////////////////////////////

DECADA:		MOV	A,DPL
		ORL	A,DPH
		JZ	DEC1 	; ПРОВЕРКА ИСХОДНОГО КОДА НА НОЛЬ

		; Получение дополнительного кода в DPTR.
		MOV	A,DPL	; 1. Инвертирование DPTR
		CPL	A
		MOV	DPL,A
		MOV	A,DPH
		CPL	A
		MOV	DPH,A
		INC	DPTR	; 2. Инкрементир. DPTR на +1.

		MOV	DECST,#00H ; Обнуление выходных переменных.
		MOV	DECML,#00H

DEC3:		MOV	A,DECML
		INC	A
		CLR	C	; C:=0.
		CLR	AC	; AC:=0.
		DA	A
		MOV	DECML,A
		JNZ	DEC2

		MOV	A,DECST
		INC	A
		CLR	C	; C:=0.
		CLR	AC	; AC:=0.
		DA	A
		MOV	DECST,A

DEC2:		INC	DPTR
		MOV	A,DPL
		ORL	A,DPH
		JNZ	DEC3 	; ПРОВЕРКА DPTR НА НОЛЬ.
		RET

DEC1:		MOV	DECST,#00H ; Обнуление выходных переменных.
		MOV	DECML,#00H
		RET

;--------------------------------------------------

;DEC_20
DEC_20:		PUSH	PSW	; Преобразование 20-ти разрядного двоичного
		PUSH	ACC	; кода из однобайтовых переменных IZMML (мл.)
		PUSH	DPL	; IZMSR (ср.) и IZMST (старш.) - в двоично
		PUSH	DPH	; десятичный код.
		PUSH	B	; Результат - в переменных:
				; ML_RAZR, SR_RAZR- 4 младших дв.-дес. разряда;
				; ST_RAZR         - 2 старших дв.-дес. разряда.

		MOV	ML_RAZR,#00H ; Обнуление переменных результата сложения
		MOV	SR_RAZR,#00H ; двоично- десятичных кодов (для пп. PAD).
		MOV	ST_RAZR,#00H

		MOV	DPL,IZMML
		MOV	DPH,IZMSR
		ANL	DPH,#03H
		LCALL	DECADA	     ; Получение двоично - десятичного кода
				     ; 10-ти младших разрядов переменной IZMML.
		MOV	SLC,DECST ; Запись его для временного хранения
		MOV	SLD,DECML ; в переменные SLC, SLD.

		MOV	A,IZMSR
		RR	A
		RR	A
		ANL	A,#03H	; Выделение 12-го и 11-го разрядов переменной
				; IZMSR, сохранение их в <C>.
		JZ	DEC_201

		MOV	DPTR,#1024H
DEC_202:	LCALL	PAD	; ST_,SR_,ML_RAZR:= ST_,SR_,ML_RAZR + 1024H.
		DEC	A
		JNZ	DEC_202

DEC_201:	MOV	A,IZMSR	; Получение в <A> байта из 8-ми старших
		RR	A	; разрядов преобразуемого 20-ти разрядного
		RR	A	; кода (4 самых старших разряда из IZMST,
		RR	A	; 4 следующих разряда - старшие из IZMSR).
		RR	A
		ANL	A,#0FH
		MOV	B,A
		MOV	A,IZMST
		RL	A
		RL	A
		RL	A
		RL	A
		ANL	A,#0F0H
		ORL	A,B

		JZ	DEC_203

		MOV	DPTR,#4096H
DEC_204:	LCALL	PAD	; ST_,SR_,ML_RAZR:= ST_,SR_,ML_RAZR + 4096H.
		DEC	A
		JNZ	DEC_204

DEC_203:	MOV	DPL,SLD
		MOV	DPH,SLC

		MOV	A,DPL
		ORL	A,DPH
		JZ	DEC_205

		LCALL	PAD  ; ST_,SR_,ML_RAZR:= ST_,SR_,ML_RAZR + SLC, SLD.
			     ; (SLS, SLD - результат преобр. пп. DECADA).
DEC_205:	POP	B
		POP	DPH
		POP	DPL
		POP	ACC
		POP	PSW
		RET

		; Сложение двоично-десятичных кодов. (Вх. параметр в <DPTR> ).
		; ST_,SR_,ML_RAZR:= ST_,SR_,ML_RAZR + <DPTR>.

PAD:		PUSH	PSW
		PUSH	ACC

		CLR	C	; C:=0.
		CLR	AC	; AC:=0.

		MOV	A,DPL
		ADDC	A,ML_RAZR

		DA	A
		MOV	ML_RAZR,A

		MOV	A,DPH
		ADDC	A,SR_RAZR

		DA	A
		MOV	SR_RAZR,A

		MOV	A,#00H
		ADDC	A,ST_RAZR

		DA	A
		MOV	ST_RAZR,A

		POP	ACC
		POP	PSW
		RET

;End of DEC_20.
;--------------------------------------------------









          ;************************************************************************************
  ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 ;**************** Тестовый режим работы ЖКИ индикатора. *****************************
;**************** 05-05-2010 ********************************************************
TEST_MODE:
          ;----------;
                ; ================== Временная задержка (<R7> x 0.1 сек.) ===============================
               ; ================== От (1х0,1)=0,1 сек. до (255х0,1)=25,5 сек. ========================
              ; ====== Входной параметр: в <R7> - кратен (целое число секунд задержки 1...255 X0,1 сек.)
             ;---------------------------------------------------------------------------------------
;        mov     R7,#5
;        lcall   delay_n_x_01_sek ; Задержка 0,5 сек.
;        ;-----------------------;
;        clr     COMM_I         ; Временно для индикации состояния.


       ;-----------------------------------------------
		
        lcall   LcdInit
        ; Общая инициализация LCD индикатора 1-8 строки, после подачи питания.
       ;********************************************************************************
		


;        ;*********************************************************************************
TEST_MODE_000:
         ;*************************************************************************
        ;******** !!! Установить режим обычного шрифта 21 символ х 8 строк.    !!!
       ;*************************************************************************
      ;********************************************************************************
        clr     Bit_Mode_12x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 12 символов х 4 строки
                                    ; формат знака 8х14 пикселей.
     ;******************************************************************
        clr     Bit_Mode_16x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.
     ;******************************************************************
        lcall   RESP
          ;------------------------------
;        ;*********************************************************************************
        ;---------------------------------------------
        mov     PR_VIDELEN,#0 ; Позитивное отображение знака.
        ;*********************************************************************************

        ;*******************************************************************************
        mov     POZITION,#0
        mov     POZ_STR,#0
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_1; '* Набор тестов ЖКИ **'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#1
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_2; 'графического индик-ра'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#2
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_3; 'BG-12864A-GPLHn$ или:'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#3
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_4; 'аналогичного ему, и, '
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#4
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_5; 'имеющего   контроллер'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#5
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_6; 'управления, совмести-'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#6
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_7; 'мый с Philips KS107/ '
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        mov     POZITION,#0
        mov     POZ_STR,#7
        mov     KOL_SIMV,#21
        mov     DPTR,#T_MOD21_8; 'KS108. Ожидание 8 сек'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        ;------------------------------------------------
        mov     R7,#80    ; Задержка 8,0 сек.
        lcall   delay_n_x_01_sek
        ;*********************************************

         ;*************************************************************************
        ;******** !!! Установить режим широкого шрифта 16 символов х 4 строки. !!!
       ;*************************************************************************
        clr     Bit_Mode_12x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 12 символов х 4 строки
                                    ; формат знака 8х14 пикселей.
     ;******************************************************************

        setb    Bit_Mode_16x4
         ;!! *************************************************************
        ;!! Установить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.
     ;******************************************************************
        lcall   RESP

        ;---------------------------------------------
        mov     PR_VIDELEN,#0 ; Позитивное отображение знака.
; ***************************************************************************
        ;-------------------------------------------------------------------
        mov     POZITION,#0
        mov     POZ_STR,#0
        mov     KOL_SIMV,#16
        mov     DPTR,#T_TST_C  ; 'Выв. шрифта 16х4'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        ;---------------------------------------------
        mov     PR_VIDELEN,#1 ; Негативное отображение знака.
; ***************************************************************************
        ;-------------------------------------------------------------------
        mov     POZITION,#0
        mov     POZ_STR,#2
        mov     KOL_SIMV,#16
        mov     DPTR,#T_TST_C  ; 'Выв. шрифта 16х4'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        ;---------
        mov     R7,#30    ; Задержка 3,0 сек.
        lcall   delay_n_x_01_sek

        ;----------------------;
        mov     PR_VIDELEN,#0 ; Позитивное отображение знака.
        lcall   RESP         ;
        ;===================;

        ;-----------------;

        mov     Ct_Gashenie_ml_A,#255
        mov     A,#0
        ;------------------------;

TEST_MODE_A:
        lcall   LcdDataWriteSt ; Запись знака в режиме широкого шрифта
                              ; на индикатор.
        push    ACC
        ;---------
        mov     R7,#3    ; Задержка 0,3 сек.
        lcall   delay_n_x_01_sek
        pop     ACC
        ;----------------------------------------------------------------------------
       ;****************************************************************************
        inc     A
        djnz    Ct_Gashenie_ml_A,TEST_MODE_A
        ;-----------------------------------


         ;*************************************************************************
        ;******** !!! Установить режим широкого шрифта 12 символов х 4 строки. !!!
       ;*************************************************************************
        cpl     Bit_Mode_12x4
         ;!! *************************************************************
        ;!! Инвертировать битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 12 символов х 4 строки
                                    ; формат знака 8х14 пикселей.
     ;******************************************************************

        cpl    Bit_Mode_16x4
         ;!! *************************************************************
        ;!! Инвертировать битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.
     ;******************************************************************

        ;***********************;
        lcall   RESP
        mov     PR_VIDELEN,#0 ; Позитивное отображение знака.
; ***************************************************************************
        ;-------------------------------------------------------------------
        mov     POZITION,#0
        mov     POZ_STR,#0
        mov     KOL_SIMV,#12
        mov     DPTR,#T_TST_D ; 'Выв.шрф.12х4'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************
        ;---------------------------------------------
        mov     PR_VIDELEN,#1 ; Негативное отображение знака.
; ***************************************************************************
        ;-------------------------------------------------------------------
        mov     POZITION,#0
        mov     POZ_STR,#2
        mov     KOL_SIMV,#12
        mov     DPTR,#T_TST_D ; 'Выв.шрф.12х4'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************


        ;---------
        mov     R7,#30    ; Задержка 3,0 сек.
        lcall   delay_n_x_01_sek


        mov     PR_VIDELEN,#0 ; Позитивное отображение знака.
        lcall   RESP         ;
        ;===================;
TEST_MODE_100:
        mov     Ct_Gashenie_ml_A,#255
        mov     A,#0
        ;------------------------;

TEST_MODE_D:
        lcall   LcdDataWriteSt ; Запись знака в режиме широкого шрифта
                              ; на индикатор кассира.
        push    ACC
        ;---------
        mov     R7,#3    ; Задержка 0,3 сек.
        lcall   delay_n_x_01_sek
        pop     ACC
        ;-----------------------------------------------------------------------------
        ;****************************************************************************
        inc     A
        djnz    Ct_Gashenie_ml_A,TEST_MODE_D
        ;-----------------------------------


         ;*************************************************************************
        ;******** !!! Установить режим обычного шрифта 21 символ х 8 строк.    !!!
       ;*************************************************************************
      ;********************************************************************************
        clr     Bit_Mode_12x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 12 символов х 4 строки
                                    ; формат знака 8х14 пикселей.
     ;******************************************************************
        clr     Bit_Mode_16x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.
     ;******************************************************************
        lcall   RESP
          ;------------------------------
;        ;*********************************************************************************
        ;---------------------------------------------
        mov     PR_VIDELEN,#0 ; Позитивное отображение знака.
        ;*********************************************************************************


        ;*******************************************************************************
        mov     POZITION,#0
        mov     POZ_STR,#2
        mov     KOL_SIMV,#6
        mov     DPTR,#T_TST_F ; 'Пример'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************


         ;*************************************************************************
        ;******** !!! Установить режим широкого шрифта 16 символов х 4 строки. !!!
       ;*************************************************************************
      ;*************************************************************************
        clr     Bit_Mode_12x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 12 символов х 4 строки
                                    ; формат знака 8х14 пикселей.
     ;******************************************************************
        setb    Bit_Mode_16x4
         ;!! *************************************************************
        ;!! Установить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.
     ;******************************************************************
        ;-------------------;
        ;-------------------------------------------------------------------
        mov     POZITION,#6
        mov     POZ_STR,#2
        mov     KOL_SIMV,#4
        mov     DPTR,#T_TST_E  ; 'Разн'
        lcall   LcdStrWriteSt_Tabl
        ;*************************************************


         ;*************************************************************************
        ;******** !!! Установить режим широкого шрифта 12 символов х 4 строки. !!!
       ;*************************************************************************
      ;********************************************************************************
        setb    Bit_Mode_12x4
         ;!! *************************************************************
        ;!! Установить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 12 символов х 4 строки. *********************
                                       ; "0" - обычный шрифт 21 символ х 8 строк
                                      ; формат знака 5х7 пикселей.
                                     ; "1" - широкий шрифт 12 символов х 4 строки
                                    ; формат знака 8х14 пикселей.
     ;******************************************************************
        clr     Bit_Mode_16x4
         ;!! *************************************************************
        ;!! Сбросить битовый признак режима широкого шрифта на
       ;!! дисплее кассира: 16 символов х 4 строки. *********************
                                 ; "0" - обычный шрифт 21 символ х 8 строк
                                ; формат знака 5х7 пикселей.
                               ; "1" - широкий шрифт 16 символов х 4 строки
                              ; формат знака 6х10 пикселей.
     ;******************************************************************
        mov     POZITION,#8
        mov     POZ_STR,#2
        lcall   SET_POZITION
        ;-------------------
        mov     A,#'ш'
        lcall   LcdDataWriteSt
        ;-------------------
        mov     A,#'р'
        lcall   LcdDataWriteSt
        ;-------------------
        mov     A,#'ф'
        lcall   LcdDataWriteSt
        ;-------------------
        mov     A,#'.'
        lcall   LcdDataWriteSt
        ;-------------------
        ;****************************************************************
        ;---------
        mov     R7,#50    ; Задержка 5,0 сек.
        lcall   delay_n_x_01_sek
        ;**************************************************************

        ljmp    TEST_MODE_000
        ;*****************************;

T_TST_C:        DB      'Выв. шрифта 16х4'
T_TST_D:        DB      'Выв.шрф.12х4'

T_TST_E:        DB      'Разн'

T_TST_F:        DB      'Пример'

T_MOD21_1:      DB      '* Набор тестов ЖКИ **'
T_MOD21_2:      DB      'графического индик-ра'
T_MOD21_3:      DB      'BG-12864A-GPLHn$ или:'
T_MOD21_4:      DB      'аналогичного ему, и, '
T_MOD21_5:      DB      'имеющего   контроллер'
T_MOD21_6:      DB      'управления, совмести-'
T_MOD21_7:      DB      'мый с Philips KS107/ '
T_MOD21_8:      DB      'KS108. Ожидание 8 сек'
;*********************************************



